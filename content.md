# Содержание

- Краткий обзор
    - Что такое JavaScript? (оживление страничек, интерпретаторы, браузер ...)
    - Что умеет JavaScript? (не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется.Что же касается остальных возможностей – они зависят от окружения, в котором запущен JavaScript)
    - Что НЕ умеет JavaScript? (JavaScript – быстрый и мощный язык, но браузер накладывает на его исполнение некоторые ограничения… Этих ограничений нет на сервере. Также плагины и расширения дают доп. разрешения) 
    Ограничения:
        - в работе с файлами
        - на взаимодействия между вкладками
        - запросы на другой домен
    - В чём уникальность JavaScript?
        - Полная интеграция с HTML/CSS.
        - Простые вещи делаются просто.
        - Поддерживается всеми распространёнными браузерами и включён по умолчанию.
    - Тенденции развития
        - HTML 5/5.1/5.2/5.3(Working Draft) 
            - здесь можно перечислить возможности, о которых важно знать. 
            - (Тенденция: JavaScript становится всё более и более мощным и возможности браузера растут в сторону десктопных приложений.)
            - проверяем поддержку HTML 5.X на caniuse
            - ищем полифилы на время интеграции во все браузеры, например https://github.com/GoogleChrome/dialog-polyfill
            - где искать полифилы http://html5please.com/#polyfill и при этом можно почитать в какой стадии поддержки та или иная фича HTML5
            - ещё список полифилов HTML5 - https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills
        - ECMAScript 6+
            - Часто браузеры внедряют фичи заранее из ещё разрабатываемого стандарта и он может поменяться, поэтому лучше всегда брать только те фичи по которым стандарт уже принят или находится на последней стадии.
            - Помните, что этот функционал добавляется в язык неспроста. Причины, по которым умные люди из TC39 это делают — улучшение качества языка, абстрагирования, удобства пользования и другие. Изучите эти новшества заранее, и к тому моменту, как они будут официально опубликованы и станут везде поддерживаться, вы сможете не теряя времени сразу приняться за работу.
            - Где почитать текущую спецификацию https://tc39.github.io/ecma262/ (репо: https://github.com/tc39/ecma262)
            - Посмотреть текущую поддержку браузерами фич из каждой спецификации http://kangax.github.io/compat-table/es2016plus/
            - Посмотреть текущие proposals https://github.com/tc39/proposals
                - Какие стадии у каждого proposal и сам процесс продвижения https://tc39.github.io/process-document/ (см. колонку Acceptance Signifies, например для stage-4 это `The addition will be included in the soonest practical standard revision`)
            - Как попробовать новые фичи.
                - babel 
                    - раньше можно было подключить preset `stage-0`, теперь отказались в сторону явного подключения каждого proposal в проект. (Пример) https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0
                    - Также отказались от единого полифила, в который входили и полифилы proposals в сторону разделения `import "@babel/polyfill"`
                        - теперь `import "core-js/shim"; // included < Stage 4 proposals`
                        - Below is a list of Stage < 3 proposal polyfills in core-js v2.
                            - https://babeljs.io/docs/en/v7-migration#remove-proposal-polyfills-in-babel-polyfill-https-githubcom-babel-babel-issues-8416
            - Тенденция: JavaScript становится всё быстрее и стабильнее, в язык добавляются новые возможности.
            - Тенденция: всё идет к полной совместимости со стандартом. В браузерах всё ещё есть кое какие не совместимости.
            - Отдельно рассмотрим фичи ES6+ в последней части.
    - Языки поверх JavaScript (TS, Dart, CoffeeScript, flowtype, ...)
    - ES6+ прямо сейчас с помощью babel
- Особенности JavaScript (тонкости)
    - Типы. Просто напомнить какие есть.
    - Особенности операторов
        - Сложения
            - Если хоть один аргумент – строка, то другой тоже приводится к строке
        - Сравнение
            - Сравнение === проверяет точное равенство, включая одинаковый тип
            - Остальные сравнения == < <= > >= осуществляют числовое приведение типа
            - Исключение – сравнение двух строк, которое осуществляется лексикографически. Символы сравниваются по своим unicode-кодам.
            - Также: значения null и undefined при == равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение null к 0, а undefined к NaN.
        - Логические операторы
            - Как и в большинстве других языков, в логических операторах используется «короткий цикл» вычислений. Например, вычисление выражения 1 && 0 && 2 остановится после первого И &&, т.к. понятно что результат будет ложным (ноль интерпретируется как false).
            - Результатом логического оператора служит последнее значение в коротком цикле вычислений. Значения хоть и интерпретируются как логические, но то, которое в итоге определяет результат, возвращается без преобразования.
        - Числа (наверное лишнее)
            - Деление на ноль, Infinity
            - NaN (Если математическая операция не может быть совершена, то возвращается специальное значение NaN. Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.)
- Важное для понимания в JavaScript (высокоуровнево как работает)
    - Замыкания, область видимости
        - Замыкания
            - Глобальный объект
                - В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект»
                - В результате инициализации, к началу выполнения кода:
                    - Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.
                    - Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них.
            - Лексическое окружение
                - Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.
                - При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
                - В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
            - Доступ ко внешним переменным
                - Каждая функция при создании получает ссылку [[Scope]] на объект с переменными LexicalEnvironment, в контексте которого была создана.
                - При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он получает ссылку на внешний объект переменных из [[Scope]].
                - Интерпретатор, при поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.
            - Что такое замыкание
                - Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
                - То есть, замыкание – это функция + внешние переменные.
                - Тем не менее, в JavaScript есть небольшая терминологическая особенность.
                - Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.
                - Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.
            - «Понимать замыкания» в JavaScript означает понимать следующие вещи:
                - Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
                - При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
                - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
    - В следствие, из понимания LexicalEnvironment можно легко понять разницу в поведении Function Declaration и Expression и то, что называется Поднятие(Hoisting)
        - Function Declaration и Expression
            - Синтаксис, при котором функция объявляется в контексте выражения (например, выражение присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода – Function Declaration.
            - Функции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.
        - Поднятие (hoisting)
            - Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации. JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после ее использования, то значение будет undefined.
    - Если чувствуете неуверенность в данном вопросе, рекомендую почитать хорошее, подробное описание здесь https://learn.javascript.ru/functions-closures
    - контекст вызова
        - Методы объектов, this
            - Контекст есть у ВЫЗОВА функции!!!! А не у самой функции. Нужно помнить наизусть 4 случая использования this:
                - 1. Простой  вызов функции вне объекта
                    Foo();
                    // undefined (если при use strict)
                    // window - при старом стандарте
                - 2. Вызов метода объекта
                    Контестом становится то что слева от функции. 
                    Совершенно не важно где функция была объявлена - ГЛАВНОЕ - на каком объекте была вызвана через точку и т.п.
                    [картинка с примером]
                - 3. Заранее известный контекст (call, apply, bind)
                    Apply - нужен для того, чтобы вызвать функцию на заранее установленном контексте.
                    Первым аргументом у apply будет контекст на котором вызвать данную функцию.
                    Аргументы в данном случае нужно передавать в массиве вторым аргументом.
                    Call – абсолютно аналогично apply только передавать аргументы можно через запятую
                    Bind - аналогично call и apply привязывает контекст, но не вызывает функцию, а возвращает функцию с привязанным контекстом.
                - 4. Создание объектов через конструктор "new"
                    Любую функцию можно вызвать с ключевым словом NEW. Тогда результатом  будет объект this, даже если явно его не вернуть. Если возвращать примитив, тогда он проигнориется и всё равно вернется this;
                - Стрелочные функции (ES6)
        - Функции-обёртки, декораторы - https://learn.javascript.ru/decorators
    - Контекст выполнения, стек
        - У каждого вызова функции есть свой «контекст выполнения» (execution context).
        - Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
        - Пример. "Степень pow(x, n) через рекурсию"
            Для `pow(2, 3)` из примера выше будет создан контекст выполнения, который будет хранить переменные x = 2, n = 3. Мы схематично обозначим его так:
            `[Контекст: { x: 2, n: 3, строка 1 }]`
            - Далее функция pow начинает выполняться.
            - требуется произвести запуск pow с новыми аргументами.
            - При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов».
            - Для нового вызова создаётся свой контекст выполнения, и управление переходит в него, а когда он завершён – старый контекст достаётся из стека и выполнение внешней функции возобновляется.
            - В результате нескольких циклов рекурсии имеем следующий "стек контекстов"
                [Контекст: { x: 2, n: 3, строка 3 }]
                [Контекст: { x: 2, n: 2, строка 3 }]
                [Контекст: { x: 2, n: 1, строка 1 }]
            - Когда функция заканчивает свою работу, возвращая 2. Текущий контекст больше не нужен и удаляется из памяти, из стека восстанавливается предыдущий:
            - Выход из pow(2, 2).
            - Выход из pow(2, 3).
            - Глубина рекурсии в данном случае составила: 3.
            - глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.
            - Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, в данном случае это приводит к тому, что возведение в степень n хранит в памяти n различных контекстов.
            - 
    - Стек. Как работает движок JS (Например, Google V8)
        - Статья http://jem-space.ru/kak-rabotaiet-javascript/
        - Движок JavaScript. Механизм состоит из двух основных компонентов:
            - Memory Heap - здесь происходит выделение памяти;
            - Call Stack - именно там находятся кадры стека при выполнении кода.
        - The Runtime. Практически каждый разработчик JavaScript использует браузерные API (например, «setTimeout»). Однако, эти API не предоставляются движком.
            - [картинка как выглядит взаимодействие движка со всем остальным]
            - Итак, у нас есть движок, но на самом деле гораздо больше - такие вещи, как веб-API, которые предоставляются браузерами: DOM, AJAX, setTimeout и многие другие. А еще, у нас есть популярный event loop и колбек очередь (callback queue).
        - Стек вызовов
            - JavaScript - это однопоточный язык программирования, что означает, что он имеет один стек вызовов. Поэтому он может делать одну вещь за раз.
            - Стек вызовов - это структура данных, которая в основном записывает, где мы находимся в программе. Если мы переходим в функцию, мы помещаем ее на вершину стека. Если мы возвращаемся из функции, мы выскочим из верхней части стека. Это все, что может делать стек.
            - [Добавить описание и картинки для краткого описания работы стека].
            - Пример 1.
                ```
                function multiply(x, y) {
                    return x * y;
                }
                function printSquare(x) {
                    var s = multiply(x, x);
                    console.log(s);
                }
                printSquare(5);
                ```
            - Когда движок начнет выполнять этот код, стек вызовов будет пуст. После этого шаги будут следующими:
                - Картинка [Call Stack 1]
            - Каждая запись в стеке вызовов называется кадром стека (Stack Frame).
            И именно так строится стек трейс, когда генерируется исключение - в основном это состояние стека вызовов, в момент когда оно произошло. Взгляните на следующий код:
            - Пример 2.
                ```
                function foo() {
                    throw new Error('SessionStack will help you resolve crashes :)');
                }
                function bar() {
                    foo();
                }
                function start() {
                    bar();
                }
                start();
                ```
            - [рис. Error with stack-trace]
            - « Blowing the stack » - происходит, когда вы достигаете максимального размера стека вызовов. Это может произойти довольно легко, например, при использовании рекурсии без тщательного тестирования кода. Посмотрите на пример:
                - Пример 3.
                    ```
                    function foo() {
                        foo();
                    }
                    foo();
                    ```
                - Движок начинает выполнение кода с вызова функции «foo». Однако, эта функция, является рекурсивной и начинает вызывать себя без каких-либо условий завершения. Таким образом, на каждом этапе выполнения, одна и та же функция снова и снова добавляется в стек вызовов. Это выглядит примерно так:
                    - [Blowing the stack]
                - В какой-то момент, количество вызовов функций в стеке вызовов превышает фактический размер стека вызовов, и браузер решает предпринять действия, выдавая ошибку, которая может выглядеть примерно так:
                    - [Error max call stack size]
    - Callback Queue
        - JavaScript является однопоточным
        - использует колбек очередь
        - очередь событий
            - Произошло одновременно несколько событий или во время работы одного случилось другое – как главному потоку обработать это?
            - Если главный поток прямо сейчас занят, то он не может срочно выйти из середины одной функции и прыгнуть в другую. А потом третью. Отладка при этом могла бы превратиться в кошмар, потому что пришлось бы разбираться с совместным состоянием нескольких функций сразу.
            - Когда происходит событие, оно попадает в очередь.
            - Внутри браузера непрерывно работает «главный внутренний цикл», который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п.
            - !!! НЕ ДОДЕЛАННО
    - Параллелизм и Event Loop (не хватает)
    - DOM
- Современный JS (ES6+)
    - Ссылки
        - https://babeljs.io/docs/en/learn.html
    - Что основного добавил ES6
        - сlasses and modules
        - iterators and for/of loops
        - Python-style generators
        - arrow functions
        - binary data
        - typed arrays
        - collections (maps, sets and weak maps)
        - promises
        - number and math enhancements
        - reflection
        - and proxies (metaprogramming for virtual objects and wrappers)
        - and many others
    - ES7 (ECMAScript 2016)
        - exponentiation operator (`**`)
        - Array.prototype.includes
    - ES8 (ECMAScript 2017)
        - async/await, which works using generators and promises
    - ES9 (ECMAScript 2018)
        - rest/spread properties
        - asynchronous iteration
        - Promise.prototype.finally()
        - additions to RegExp
    - ES.Next - features are more correctly called proposals, because, by definition, the specification has not been finalized yet
        - 

- LocalStorage
- Workers

- На будущее
    - Может получиться очень хороший рассказ о том как работает JS(движок и вещи рядом) на основе картинки взаимодействия движка с WebApi(document, XHR, setTimeout) и с EventLoop + CallbackQueue(onClick, onLoad, onDone)
        - Источники
            - http://jem-space.ru/kak-rabotaiet-javascript/
            - https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e