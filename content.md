# Содержание

- Содержание
  
  - Что будет в докладе, а что нет?
    - Все темы из доклада.
    - Все важные темы не вошедшие в доклад. Но вот ссылки.
  
  - Формат такой. Я рассказываю, все вопросы в конце, но если кто-то какой-то вопрос не понял приоритетнее себе записать и разобраться позже, т.к. инфы много. Но если чувствуете, что вот всё было понятно, и вдруг на каком-то месте выпал, тогда задавайте вопрос, чтобы вернуться в колею. Если таких вопросов будет не много, тогда буду отвечать. Те кто и так понимают, все вопросы в конце.

  - Краткий обзор.
    - Что такое JavaScript?
      - Изначально создавался для того, чтобы "оживить" web-странички.
      - JavaScript может выполняться не только в браузере, а где угодно, браузер лишь один из возможных Runtime-environment, нужна лишь специальная программа – интерпретатор.
      - Во все основные браузеры встроен интерпретатор JavaScript (движок).
    - Что умеет JavaScript? (Сам по себе он основные ограничения это то, что он не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется.Что же касается остальных возможностей – они зависят от окружения, в котором запущен JavaScript)
    - Что НЕ умеет JavaScript? (JavaScript – мощный язык, но браузер, когда JS работает в его окружении, накладывает на его исполнение некоторые ограничения… Этих ограничений нет на сервере NodeJS. Доп. разрешения в браузере можно получить с помощью плагинов или расширений)
    - Примеры ограничений в браузере:
      - на работу с файлами
      - на взаимодействия между вкладками
      - запросы на другой домен
    - В чём уникальность JavaScript?
      - Полная интеграция с HTML/CSS.
      - Поддерживается всеми распространёнными браузерами и включён по умолчанию.
  
  - Как работает движок JS (на примере Google V8). Ну и про стек.
    - Движок JavaScript. Механизм состоит из двух основных компонентов:
      - ![только движок](https://i.imgur.com/DXx3GFx.png)
      - Memory Heap - здесь происходит выделение памяти;
      - Call Stack - именно там находятся кадры стека при выполнении кода.
    - The Runtime. Практически каждый разработчик JavaScript использует браузерные API (например, «setTimeout»). Однако, эти API не предоставляются движком.
      - ![полная схема, как выглядит взаимодействие движка со всем остальным](https://i.imgur.com/kFkIDpj.png)
      - Итак, у нас есть движок, но на самом деле гораздо больше - такие вещи, как веб-API, которые предоставляются браузерами: DOM, AJAX, setTimeout и многие другие. А еще, у нас есть популярный event loop и колбек очередь (callback queue).
    - Стек вызовов
      - JavaScript - это однопоточный язык программирования, что означает, что он имеет один стек вызовов. Поэтому он может делать одну вещь за раз.
      - Стек вызовов - это структура данных, которая в основном записывает, где мы находимся в программе. Если мы переходим в функцию, мы помещаем ее на вершину стека. Если мы возвращаемся из функции, мы выскочим из верхней части стека. Это все, что может делать стек.
      - Пример 1. 
      - ![](https://i.imgur.com/DbzJlzp.png)
        ```js
        function multiply(x, y) {
            return x * y;
        }
        function printSquare(x) {
            var s = multiply(x, x);
            console.log(s);
        }
        printSquare(5);
        ```
      - Когда движок начнет выполнять этот код, стек вызовов будет пуст. После этого шаги будут следующими:
        - Картинка ![Call Stack 1](https://i.imgur.com/Prf8QbG.png)
      - Каждая запись в стеке вызовов называется кадром стека (Stack Frame).
        И именно так строится стек трейс, когда генерируется исключение - в основном это состояние стека вызовов, в момент когда оно произошло. 
      - «Blowing the stack» - происходит, когда вы достигаете максимального размера стека вызовов. Это может произойти довольно легко, например, при использовании рекурсии
    - Статья http://jem-space.ru/kak-rabotaiet-javascript/ или она же https://habr.com/ru/company/ruvds/blog/337042/

  - Event Loop, Callback Queue. Асинхронность.
    - Ограничения однопоточной модели выполнения кода
      - ![вкладка не отвечает](https://i.imgur.com/SYF7cJx.png)
      - Представьте себе сложный алгоритм обработки изображений, реализация которого запускается в браузере. Когда в стеке вызовов есть работающая функция, браузер не может делать больше ничего. Он заблокирован.
      - Как только браузер начинает выполнять слишком много задач, он может достаточно продолжительное время не реагировать на воздействия пользователя.
      - Как же быть, если хочется, чтобы веб-приложение и выглядело хорошо, и могло выполнять сложные вычисления?
    - Изучение цикла событий
      - Сам движок V8 полностью однопоточен.
        - ![полная схема, как выглядит взаимодействие движка со всем остальным](https://i.imgur.com/kFkIDpj.png)
        - Есть и другие, служебные потоки, например, для сетевых коммуникаций. Но управлять служебными потоками мы не можем. Ими управляет браузер.
      - В реальности движок не работает в изоляции — его собственный код выполняется внутри некоего окружения, которым, для большинства разработчиков, является либо браузер, либо Node.js
      - Общей характеристикой всех подобных сред является встроенный механизм, который называется циклом событий (event loop). Он поддерживает выполнение фрагментов программы, вызывая для этого JS-движок.
      - Это означает, что движок можно считать средой выполнения любого JS-кода, вызываемой по требованию. А планированием событий (то есть — сеансов выполнения JS-кода) занимаются механизмы окружения, внешние по отношению к движку.
        - Взгляните на следующую схему: ![полная схема](https://i.imgur.com/kFkIDpj.png)
      - А что представляют собой Web API? В целом, это — потоки, к которым у нас нет прямого доступа, мы можем лишь выполнять обращения к ним. Они встроены в браузер, где и выполняются асинхронные действия.
      - Как работает Event Loop?
      - ![Event Loop + Callback Queue](https://i.imgur.com/nO2FtvX.png)
      - Event Loop решает одну основную задачу: наблюдает за стеком вызовов (call stack) и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие(callback) из очереди и помещает его в стек, что приводит к запуску этого события(callback) на выполнение.
      - Подобная итерация называется тиком (tick) Event Loop. Каждое событие — это просто коллбэк.
      - Рассмотрим следующий пример: 
      - ![](https://i.imgur.com/ywGFdkW.png)
      ```js
          console.log('Hi');
          setTimeout(function cb1() {
              console.log('cb1');
          }, 5000);
          console.log('Bye');
      ```
      - Займёмся пошаговым «выполнением» этого кода и посмотрим, что при этом происходит в системе.
        - По шагам
          1. Пока ничего не происходит. Консоль браузера чиста, стек вызовов пуст. ![рис](https://i.imgur.com/fCT3MC2.png)
          2. Команда console.log('Hi') добавляется в стек вызовов. ![рис](https://i.imgur.com/YgN6Z6i.png)
          3. Команда console.log('Hi') выполняется. ![рис](https://i.imgur.com/DD2Wjbp.png)
          4. Команда console.log('Hi') удаляется из стека вызовов. ![рис](https://i.imgur.com/b6wJI4q.png)
          5. Команда setTimeout(function cb1() { ... }) добавляется в стек вызовов. ![рис](https://i.imgur.com/MVvU75x.png)
          6. Команда setTimeout(function cb1() { ... }) выполняется. Браузер создаёт таймер, являющийся частью Web API. Он будет выполнять обратный отсчёт времени. ![рис](https://i.imgur.com/dEamvY3.png)
          7. Команда setTimeout(function cb1() { ... }) завершила работу и удаляется из стека вызовов. ![рис](https://i.imgur.com/Be5fINg.png)
          8. Команда console.log('Bye') добавляется в стек вызовов. ![рис](https://i.imgur.com/K2M6EQ3.png)
          9.  Команда console.log('Bye') выполняется. ![рис](https://i.imgur.com/tVKUbV3.png)
          10. Команда console.log('Bye') удаляется из стека вызовов. ![рис](https://i.imgur.com/kTetVTc.png)
          11. После того, как пройдут, как минимум, 5000 мс., таймер завершает работу и помещает коллбэк cb1 в очередь коллбэков. ![рис](https://i.imgur.com/LE7t08x.png)
          12. Цикл событий берёт c функцию cb1 из очереди коллбэков и помещает её в стек вызовов. ![рис](https://i.imgur.com/WsbTA32.png)
          13. Функция cb1 выполняется и добавляет console.log('cb1') в стек вызовов. ![рис](https://i.imgur.com/WTvloc5.png)
          14. Команда console.log('cb1') выполняется. ![рис](https://i.imgur.com/Yw7b1C4.png)
          15. Команда console.log('cb1') удаляется из стека вызовов. ![рис](https://i.imgur.com/25AS2IK.png)
          16. Функция cb1 удаляется из стека вызовов. ![рис](https://i.imgur.com/BXnVbnT.png)
      - gif. ![Как работает callback queue](https://i.imgur.com/BQamRr1.gif)
      - Часто при объяснении асинхронного программирования на JS рекомендуют использовать команду setTimeout(callback, 0). Теперь вы знаете, как работает цикл событий и что происходит при вызове setTimeout. Учитывая это, вполне очевидно то, что вызов setTimeout со вторым аргументом, равным 0, просто откладывает вызов коллбэка до момента очищения стека вызовов. 
      - На месте setTimeout может быть любой другой метод из WebAPI браузера.
      - Обзорно про WebAPI браузера https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Introduction#%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%91%D0%BD%D0%BD%D1%8B%D0%B5_API_%D0%B1%D1%80%D0%B0%D1%83%D0%B7%D0%B5%D1%80%D0%B0
      - Пример
        - Итак, например, когда ваша программа выполняет Ajax-запрос для загрузки каких-то данных с сервера, вы пишете команду для записи этих данных в переменную response внутри коллбэка, и JS-движок сообщает окружению: «Послушай, я собираюсь приостановить выполнение программы, но когда ты закончишь выполнять этот сетевой запрос и получишь какие-то данные, пожалуйста, вызови этот коллбэк».
        - Затем браузер устанавливает прослушиватель, ожидающий ответ от сетевой службы, и когда у него есть что-то, что можно возвратить в программу, выполнившую запрос, он планирует вызов коллбэка, добавляя его в Callback Queue.
    - Примечание. Вложенные (синхронные) события.
      - Обычно возникающие события «становятся в очередь».
      - Но в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.
      - [рис. Вложенные (синхронные) события]
      - Делаем события асинхронными через setTimeout(…,0)
        - можно запланировать text.focus() чуть позже через setTimeout(..., 0)
        ```js
            setTimeout(function() {
              text.focus(); // сработает после onclick
            }, 0);
        ```
      - Так событие попадёт в очередь и обработается асинхронно, как только до него дойдёт очередь.
      - Чтобы сделать событие гарантированно асинхронным, используется вызов через `setTimeout(func, 0)`.
    - Почитать дополнительно.
      - Статья. https://habr.com/ru/company/ruvds/blog/340508/
      - Какие теперь появились возможности в ES6
        - `но до ES6 JavaScript, несмотря на то, что он позволял выполнять асинхронные вызовы (вроде вышеописанного setTimeout), не содержал встроенных механизмов асинхронного программирования. JS-движки занимались только однопоточным выполнением неких фрагментов кода`
      - Существует спецификация Web Workers, которая позволяет запускать дополнительные JavaScript-процессы(workers). Они могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе. Такие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно.

  - Промисы, в сравнении с callback.
    - Как выглядит асинхронный код на колбеках. ![code](https://i.imgur.com/96vwh9T.png)
      ```js
      listen('click', function (e){
        setTimeout(function(){
          ajax('https://api.example.com/endpoint', function (text){
            if (text == "hello") {
              doSomething();
            }else if (text == "world") {
              doSomethingElse();
            }
          });
        }, 500);
      });
      ```
      - 
      ```js
      listen('click', function (e) {
        
      // ..
      });
      ```
      - 
      ```js
      setTimeout(function(){
          // ..
      }, 500);
      ```
      - 
      ```js
      ajax('https://api.example.com/endpoint', function (text){
          // ..
      });
      ```
      - 
      ```js
      if (text == "hello") {
          doSomething();
      }
      else if (text == "world") {
          doSomethingElse();
      }
      ```
    - Promise – предоставляют удобный способ организации асинхронного кода.
    - Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).
      - ![ожидает-выполненно](https://i.imgur.com/9oNHU4h.png)
    - На promise можно навешивать коллбэки двух типов:
      - onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
      - onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».
    - Способ использования, в общих чертах, такой:
      - Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
      - Внешний код, получив promise, навешивает на него обработчики.
      - По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
    - Универсальный метод для навешивания обработчиков:
      - ![навешивания обработчиков](https://i.imgur.com/uAURtkT.png)
      - чтобы поставить обработчик только на ошибку, вместо `.then(null, onRejected)` можно написать `.catch(onRejected)`
    - Рассмотрим пример. Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:
      - ![Пример](https://i.imgur.com/Uid5WUP.png)
      ```text
      - Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
      - Внешний код, получив promise, навешивает на него обработчики.
      - По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.
      ```
    - Особенности
      - Promise после reject/resolve – неизменны. Когда промис переходит в состояние «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда. Например, вызвав один раз `resolve()`, все дальнейшие `resolve/reject` будут просто проигнорированы.
    - Цепочки промисов
      - «Чейнинг» (chaining), то есть возможность строить асинхронные цепочки из промисов – пожалуй, основная причина, из-за которой существуют и активно использовались промисы.
      - Но это же и их минус. В случаях более менее сложного кода, читабельность и поддержка кода очень усложняются.
      - Немного примеров с цепочками мы увидим в следующей теме, когда сравним с синтаксисом async/await.
      - Почитать здесь. https://learn.javascript.ru/promise#tsepochki-promisov
    - Почитать самостоятельно.
      - Проглатывание исключений, Обработка неперехваченных исключений
    - Источники.
      - https://learn.javascript.ru/promise (Просто)
      - https://habr.com/ru/company/ruvds/blog/340508/ (Промисы, Проглатывание исключений, Обработка неперехваченных исключений, 5 аргументов почему async/await вместо промисов)
  
  - ES8: async / await
    - В JavaScript ES8 появилась конструкция async / await, которая упрощает работу с промисами.
    - Асинхронные функции объявляют, пользуясь ключевым словом async. Такая функция возвращает объект AsyncFunction. Этот объект представляет собой асинхронную функцию, которая выполняет код, находящийся внутри неё.
    - Когда асинхронная функция вызывается, она возвращает объект Promise. Если такая функция возвращает значение, которое не является объектом Promise, этот объект будет автоматически создан и разрешён с использованием значения, возвращённого функцией. Если функция, объявленная с ключевым словом async, выдаст исключение, промис будет отклонён с этим исключением.
    - Функция, объявленная с ключевым словом async, может содержать выражение с ключевым словом await, которое приостанавливает выполнение функции и ожидает разрешения промиса, фиругирующего в данном выражении. После этого выполнение async-функции продолжается, и, например, осуществляется возврат полученного после разрешения промиса значения.
    - Объекты Promise в JavaScript можно рассматривать как эквиваленты Task из C#.
    - Цель async/await заключается в том, чтобы упростить использование промисов.
    - Ключевое слово await можно использовать только в функциях, объявленных с ключевым словом async. Оно позволяет организовать ожидание разрешения промиса. Если мы используем промисы за пределами async-функций, нам всё ещё нужно использовать коллбэки блока then:
      - рис. [Ключевое слово await можно использовать только в функциях, объявленных с ключевым словом async]
    - 5 советов по написанию надёжного асинхронного кода, который легко поддерживать
      - Прямо из статьи уже сделать слайды. Т.к. уже и так много. https://habr.com/ru/company/ruvds/blog/340508/
      - Чистота кода. Использование конструкции async / await позволяет вам писать гораздо меньше кода.
      - Обработка ошибок. Конструкция async / await позволяет обрабатывать синхронные и асинхронные ошибки с использованием одних и тех же механизмов. А именно, речь идёт о широко известном выражении try / catch.
      - Обработка условий. Применение async / await упрощает написание кода, использующего условия. Вот — код, основанный на промисах:
      - Трассировка стека. В отличие от async / await, стек ошибки, возвращённый из цепочки промисов, не содержит сведений о точном месте, в котором произошла ошибка.
      - Отладка
    - Почитать.
      - generators
      - async/await, which works using generators and promises

  - DOM
    - Окружение: DOM, BOM и JS
      - Сам по себе язык JavaScript не предусматривает работы с браузером. Он вообще не знает про HTML. Но позволяет легко расширять себя новыми функциями и объектами.
      - На рисунке ниже схематически отображена структура, которая получается если посмотреть на совокупность браузерных объектов
        - ![совокупность браузерных объектов](https://i.imgur.com/yQGgBrN.png)
      - Объектная модель браузера (BOM)
        - BOM – это объекты для работы с чем угодно, кроме документа.
        - Например:
          - Объект navigator содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства: navigator.userAgent – содержит информацию о браузере и navigator.platform – содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.
          - Объект location содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.
          - Функции alert/confirm/prompt – тоже входят в BOM.
    - DOM – это представление документа в виде дерева объектов, доступное для изменения через JavaScript.
      - рис. [Пример DOM]
      - Всё, что есть в HTML, находится и в DOM.
      - Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом, и находится в дереве DOM непосредственно перед <html>. На иллюстрациях выше этот факт скрыт, поскольку мы с этим узлом работать не будем, он никогда не нужен.
      - Даже сам объект document, формально, является DOM-узлом, самым-самым корневым.
    - Возможности, которые дает DOM
      - DOM нужен для того, чтобы манипулировать страницей – читать информацию из HTML, создавать и изменять элементы.
      - У элементов DOM есть свойства и методы, которые позволяют изменять их.
    - Поиск: getElement* и querySelector* и не только
        - ![getElementById](https://i.imgur.com/L5VFk8V.png)
      - Основные методы поиска
        - getElementsByTagName - ищет все элементы с заданным тегом tag внутри элемента elem и возвращает их в виде списка.
        - document.getElementsByName - позволяет получить все элементы с данным атрибутом name.
        - getElementsByClassName - возвращает коллекцию элементов с классом className
        - querySelectorAll - возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css.
        - querySelector - возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
        - matches - ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false.
        - closest - ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.
        - Итого - Есть 6 основных методов поиска элементов DOM:
          - ![6 основных методов поиска](https://i.imgur.com/qXVjVLY.png)
        - Практика показывает, что в 95% ситуаций достаточно querySelector/querySelectorAll. Хотя более специализированные методы getElement* работают чуть быстрее, но разница в миллисекунду-другую редко играет роль.
        - Если нужно найти один элемент используйте `querySelector()`, а не `querySelectorAll(...)[0]`, т.к. querySelectorAll будет искать до конца документа и потом только выберет первый элемент. А querySelector остановится на первом.
      - Изменение и манипуляция
        ```js
            parent.appendChild(newChild);
            parent.removeChild(child);
            parent.insertBefore(newChild, refNode);
            parent.insertAdjacentHTML("beforeBegin|afterBegin|beforeEnd|afterEnd", html);
            parent.insertAdjacentElement("beforeBegin|...|afterEnd", element) (кроме FF);
            parent.insertAdjacentText("beforeBegin|...|afterEnd", text) (кроме FF);
            document.write(...);
            node.append(...nodes);
            node.prepend(...nodes);
            node.after(...nodes);
            node.before(...nodes);
            node.replaceWith(...nodes);
        ```
  
  - Основы работы с событиями.
    - Для реакции на действия посетителя и внутреннего взаимодействия скриптов существуют события.
      - Событие – это сигнал от браузера о том, что что-то произошло. Существует много видов событий. Посмотрим список самых часто используемых, пока просто для ознакомления:
      - ![Для слайда. Скопировать c сайта](https://i.imgur.com/4705yHy.png) 
      - Для слайда. Скопировать c сайта https://learn.javascript.ru/introduction-browser-events
    - Назначение обработчиков событий
      - Событию можно назначить обработчик(callback), то есть функцию, которая сработает, как только событие произошло.
      - Использование атрибута HTML
        - ![onclick](https://i.imgur.com/kkvyM1R.png)
      - Использование свойства DOM-объекта
        - ![elem.onclick](https://i.imgur.com/VsxlUZj.png)
      - Так как DOM-свойство onclick, в итоге, одно, то назначить более одного обработчика так нельзя.
      - Методы addEventListener и removeEventListener являются предпочитаемым способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков.
        - ![addEventListener](https://i.imgur.com/nz9eUSK.png)
        - ![removeEventListener](https://i.imgur.com/7Dv3DG0.png)
        - Удаление требует именно ту же функцию. Для удаления нужно передать именно ту функцию-обработчик которая была назначена.
        - Если функцию не сохранить где-либо, а просто передать в addEventListener, как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно.
    - Объект события
      - event.type
      - event.currentTarget
      - event.clientX / event.clientY
      - Есть также и ряд других свойств, в зависимости от событий,
    - Всплытие и перехват
      - Всплытие
        - Этот обработчик для `<div>` сработает, если вы кликните по вложенному тегу `<em>` или `<code>`:
        - ![Всплытие](https://i.imgur.com/g8IK6gB.png)
        - При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.
        - Всплытие гарантирует, что клик по внутреннему <p> вызовет обработчик onclick (если есть) сначала на самом <p>, затем на элементе <div> далее на элементе <form>, и так далее вверх по цепочке родителей до самого document.
        - ![Визуализация всплытия](https://i.imgur.com/l6fZRiv.png)
        - Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как event.target.
        - Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.
      - Прекращение всплытия
        - Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента <html>, а затем до document, вызывая все обработчики на своем пути.
        - Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
        - Для остановки всплытия нужно вызвать метод `event.stopPropagation()`.
        - ![stopPropagation](https://i.imgur.com/6JzIPTI.png)
        - Не прекращайте всплытие без необходимости!
          - Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.
          - Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.
      - Погружение
        - В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».
        - Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.
        - Строго говоря, стандарт выделяет целых три стадии прохода события:
          - ![три стадии прохода события](https://i.imgur.com/Sd40X9r.png)
          - Событие сначала идет сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).
          - Событие достигло целевого элемента. Это – «стадия цели» (target stage).
          - После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).
        - Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.
        - Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener:
          - Если аргумент true, то событие будет перехвачено по дороге вниз.
          - Если аргумент false, то событие будет поймано при всплытии.
      - Приём проектирования "поведение"
        - Шаблон проектирования «поведение» (behavior) позволяет задавать хитрые обработчики на элементе декларативно, установкой специальных HTML-атрибутов и классов.
        - Приём проектирования «поведение» состоит из двух частей: 
          - Элементу ставится атрибут, описывающий его поведение.
          - При помощи делегирования ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.
          - Пример
            - Например, добавим «поведение», которое всем элементам, у которых стоит атрибут data-counter, будет при клике увеличивать значение на 1:
            - ![Пример](https://i.imgur.com/wg62aZw.png)

- Особенности JavaScript (мелкие тонкости) [сокращаю]
  - Типы.
    - Есть 5 «примитивных» типов и объекты:
      - ![5 «примитивных» типов](https://i.imgur.com/3xc7ndF.png)
  - Особенности операторов.
    - Сложения.
      - Если хоть один аргумент – строка, то другой тоже приводится к строке.
    - Сравнение.
      - Сравнение === проверяет точное равенство, включая одинаковый тип.
      - Остальные сравнения == < <= > >= осуществляют числовое приведение типа.
      - Исключение – сравнение двух строк, которое осуществляется лексикографически. Символы сравниваются по своим unicode-кодам.
      - Также: значения null и undefined при == равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение null к 0, а undefined к NaN.
    - Логические операторы
      - Как и в большинстве других языков, в логических операторах используется «короткий цикл» вычислений. Например, вычисление выражения 1 && 0 && 2 остановится после первого И &&, т.к. понятно что результат будет ложным (ноль интерпретируется как false).
      - Результатом логического оператора служит последнее значение в коротком цикле вычислений. Значения хоть и интерпретируются как логические, но то, которое в итоге определяет результат, возвращается без преобразования.
    - Числа (наверное лишнее)
      - Деление на ноль, Infinity
      - NaN (Если математическая операция не может быть совершена, то возвращается специальное значение NaN. Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.)
    - Если хоть, в чем-то не уверенны, прочитать здесь. https://learn.javascript.ru/javascript-specials Хорошо и просто расписанно.

- Важное для понимания в JavaScript (высокоуровнево как работает).

  - Глобальный объект, инициализация. Функции. Поднятие (hoisting).
    - Функции в JS так-называемые "объекты первого класса". Это элементы, которые могут быть переданы как параметр, возвращены из функции, присвоены переменной. Это ни как не связанно с понятием класс, это как понятие социальной дискриминации «людьми второго сорта».
      - Общий синтаксис функции. Такой синтаксис объявления функции называется "Function Declaration".
        - ![синтаксис](https://i.imgur.com/OgKyJ7d.png)
        - return - возвращается любое значени. Если его нет, результатом функции вернётся `undefined`, как если бы мы написали `return undefined`
      - Можно присвоить функцию в переменную это называется «Function Expression», это ещё более наглядно показывает, что функция – это всего лишь разновидность значения переменной.
        - ![синтаксис](https://i.imgur.com/bUcAeDz.png)
      - Кажется, что будет работать одинаково, но есть ньюанс. Ньюанс в том, что "Function Declaration" уже в начале выполнения скрипта будет инициализированна, а «Function Expression», как и инициализация остальных переменных будет `undefined`, до того момента, пока поток выполнения не дойдёт до строчки «Function Expression». Чтобы понять почему так, нужно просто понять как происходит инициализация.
    - Глобальный объект и инициализация.
      - Механизм работы функций и переменных в JavaScript очень отличается от большинства языков.
      - В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект».
        - В браузере этот объект явно доступен под именем window.
      - Важный момент. Инициализация происходит следующим образом.
        - Выполнение скрипта происходит в две фазы:
          1. На первой фазе происходит инициализация, подготовка к запуску.
             - Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var. Каждое такое объявление добавляется в window.
             - Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined.
          2. На второй фазе – собственно, выполнение.
             - Присваивание (=) значений переменных происходит, когда поток выполнения доходит до соответствующей строчки кода, до этого они undefined.
        - ![Пример](https://i.imgur.com/JzEHwqJ.png)
    - И наконец. Разница между FunctionDeclaration и FunctionExpression. Поднятие(Hoisting). (из понимания LexicalEnvironment)
      - Function Declaration и Expression
        - Синтаксис, при котором функция объявляется в контексте выражения (например, выражение присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода – Function Declaration.
        - Функции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.
      - Поднятие (hoisting)
        - Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации. JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после ее использования, то значение будет undefined.
      - Подробнее описание здесь https://learn.javascript.ru/functions-closures

  - Замыкания, функции изнутри.
    - Лексическое окружение(LexicalEncvironment), объект переменных.
      - Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.
      - При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
      - В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
      - Рассмотрим пример.
        - ![рис](https://i.imgur.com/XHBiQev.png)
          - До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект LexicalEnvironment и заполняет его.
          - В данном случае туда попадает аргумент name и единственная переменная phrase:
        - ![рис](https://i.imgur.com/dD5Flcq.png)
          - Функция выполняется.
          - Во время выполнения происходит присвоение локальной переменной phrase, то есть, другими словами, присвоение свойству LexicalEnvironment.phrase нового значения:
        - ![рис](https://i.imgur.com/yGcBB4B.png)
          - В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит. Через некоторое время мы рассмотрим более сложные ситуации, при которых объект с переменными сохраняется и после завершения функции. 
    - Доступ ко внешним переменным.
      - ![рис](https://i.imgur.com/NPVmznX.png)
        - Из функции мы можем обратиться не только к локальной переменной, но и к внешней:
      - Каждая функция при создании получает ссылку [[Scope]] на объект с переменными LexicalEnvironment, в контексте которого была создана.
      - При запуске функции создаётся новый объект с переменными LexicalEnvironment)(внутри функции). Он получает ссылку на внешний LexiacalEnvironment(объект переменных) из [[Scope]].
      - Интерпретатор, при поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке в внешнем LexicalEnvironment с места своего создания.
        - ![Пример](https://i.imgur.com/SxkqzX7.png)
        - ![Пример. Вложенные функции смотрят на SCOPE друг друга](https://i.imgur.com/XnbmQQf.png)
    - Что такое замыкание
      - Пример. ![Пример](https://i.imgur.com/RKMmyvH.png)
      - Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
      - То есть, замыкание – это функция + внешние переменные.
      - Тем не менее, в JavaScript есть небольшая терминологическая особенность.
      - Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные с места создания функции(её места рождения).
      - Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего Lexical Environment.
    - «Понимать замыкания» в JavaScript означает понимать следующие вещи:
      - Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
      - При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
      - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».

  - Контекст вызова
    - Методы объектов, this
      - Контекст есть у ВЫЗОВА функции!!!! А не у самой функции. Нужно помнить наизусть 4 случая использования this:
        1. Простой вызов функции вне объекта
             Foo();
             // undefined (если при use strict)
             // window - при старом стандарте
        2. Вызов метода объекта
             Контестом становится то что слева от функции.
             Совершенно не важно где функция была объявлена - ГЛАВНОЕ - на каком объекте была вызвана через точку и т.п.
             [картинка с примером]
        3. Заранее известный контекст (call, apply, bind)
             Apply - нужен для того, чтобы вызвать функцию на заранее установленном контексте.
             Первым аргументом у apply будет контекст на котором вызвать данную функцию.
             Аргументы в данном случае нужно передавать в массиве вторым аргументом.
             Call – абсолютно аналогично apply только передавать аргументы можно через запятую
             Bind - аналогично call и apply привязывает контекст, но не вызывает функцию, а возвращает функцию с привязанным контекстом.
        4. Создание объектов через конструктор "new"
             Любую функцию можно вызвать с ключевым словом NEW. Тогда результатом будет объект this, даже если явно его не вернуть. Если возвращать примитив, тогда он проигнориется и всё равно вернется this;
        - Стрелочные функции (ES6)
        - Контекст для Function Expression
          - Пример с setTimeout
    - Функции-обёртки, декораторы - https://learn.javascript.ru/decorators

  - Тенденции развития
    - HTML 5/5.1/5.2/5.3(Working Draft). Стандарт HTML 5 принёс много, но прогресс идёт и выпускаются 5.1/5.2/5.3(Working Draft)
      - (Тенденция: JavaScript становится всё более и более мощным и возможности браузера растут в сторону десктопных приложений.)
      - Проверяем поддержку HTML 5.X на caniuse
      - Полифиллы хороши тем, что мы просто подключаем их и используем везде современный DOM/JS, а когда старые браузеры окончательно отомрут – просто выкинем полифилл, без изменения кода. Почитать про полифилы https://learn.javascript.ru/dom-polyfill
      - Ищем полифилы на время интеграции во все браузеры, например https://github.com/GoogleChrome/dialog-polyfill
      - Где искать полифилы http://html5please.com/#polyfill и при этом можно почитать в какой стадии поддержки та или иная фича HTML5
      - Ещё список полифилов HTML5 - https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills
    - ECMAScript 6+
      - ECMAScript - это спецификация на основе которой работает язык JS. Выход спецификации ECMAScript 6 принёс самые большие изменения в язык в 2015 году и стех пор с темпом раз в год выпускаются новые спецификации ES7, ES8, ES9
      - Часто браузеры внедряют фичи заранее из ещё разрабатываемого стандарта и он может поменяться, поэтому лучше всегда брать только те фичи по которым стандарт уже принят или находится на последней стадии `stage-4`.
      - Помните, что этот функционал добавляется в язык неспроста. Причины, по которым умные люди из TC39 это делают — улучшение качества языка, абстрагирования, удобства пользования и другие. Изучите эти новшества заранее, и к тому моменту, как они будут официально опубликованы и станут везде поддерживаться, вы сможете не теряя времени сразу приняться за работу.
      - Ссылка на спецификацию https://tc39.github.io/ecma262/ (репо: https://github.com/tc39/ecma262)
      - Текущая поддержка браузерами фич из каждой спецификации http://kangax.github.io/compat-table/es2016plus/
      - Текущие proposals https://github.com/tc39/proposals
        - Какие стадии у каждого proposal и сам процесс продвижения https://tc39.github.io/process-document/ (см. колонку Acceptance Signifies, например для stage-4 это `The addition will be included in the soonest practical standard revision`)

    - Как попробовать новые фичи.
      - ES6+ прямо сейчас с помощью babel
      - TypeScript
    - Языки поверх JavaScript, компилятся в JS (TS, Dart, CoffeeScript, flowtype, ...)
    - Тенденция: JavaScript становится всё быстрее и стабильнее, в язык добавляются новые возможности.
    - Тенденция: всё идет к полной совместимости со стандартом. В разных браузерах разная степень отставания в имплементации стандартов.
    - Отдельно рассмотрим фичи ES6+ в последней части.

  - Современный JS (ES6+)
    - Что основного добавил ES6
      - сlasses and modules
      - iterators and for/of loops
      - Python-style generators
      - arrow functions
      - binary data
      - typed arrays
      - collections (maps, sets and weak maps)
      - (+)promises
      - number and math enhancements
      - reflection
      - and proxies (metaprogramming for virtual objects and wrappers)
      - and many others
    - ES7 (ECMAScript 2016)
      - exponentiation operator (`**`)
      - Array.prototype.includes
    - ES8 (ECMAScript 2017)
      - (+)async/await, which works using generators and promises
    - ES9 (ECMAScript 2018)
      - rest/spread properties
      - asynchronous iteration
        - http://2ality.com/2016/10/asynchronous-iteration.html
        - https://v8.dev/blog/fast-async
      - Promise.prototype.finally()
      - additions to RegExp
    - ES.Next - features are more correctly called proposals, because, by definition, the specification has not been finalized yet

- Источники
  - http://jem-space.ru/kak-rabotaiet-javascript/
  - https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e
  - Цикл статей.
    - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await https://habr.com/ru/company/ruvds/blog/340508/
    - Как работает JS: обзор движка, механизмов времени выполнения, стека вызовов https://habr.com/ru/company/ruvds/blog/337042/
- Ссылки
  - https://babeljs.io/docs/en/learn.html
  - Просто про DOM https://learn.javascript.ru/document
  - Почитать про DOM-полифилы https://learn.javascript.ru/dom-polyfill


- Важно знать. Что ещё почитать в порядке важности:
  - Промисы, подробнее.
  - AJAX(XMLHttpRequest) и fetch.
  - Прототипы.
  - Преобразование типов для примитивов.

- Дополнительно
  - LocalStorage
  - WebWorkers
  - ServiceWorkers

- На будущее
  - Может получиться очень хороший рассказ о том как работает JS(движок и вещи рядом) на основе картинки взаимодействия движка с WebApi(document, XHR, setTimeout) и с EventLoop + CallbackQueue(onClick, onLoad, onDone), опираясь на цикл статей.

- Открытые вопросы
  - Где выполняется функция (executor function) передаваемая в `new Promoise` 
    ```js
    const myFirstPromise = new Promise((resolve, reject) => {
      // выполняется асинхронная операция, которая в итоге вызовет:
      //
      //   resolve(someValue); // успешное завершение
      // или
      //   reject("failure reason"); // неудача
    });
    ```
    - Статья, про то, что конструктор промиса и executor function вызываются синхронно https://www.bennadel.com/blog/3296-the-es6-promise-constructor-and-its-executor-function-are-invoked-synchronously.htm
  - Контекст вызова в FunctionExpression, ArrowFunction. Пример с setTimeout с потерей контекста.
  - Как сделать тяжелую операцию как (making huge calculations like over a 100 million for-loop iteration is somewhat slow) без блокировки.
  - Task Queue, Render Queue https://medium.com/@siddharthac6/javascript-execution-of-synchronous-and-asynchronous-codes-40f3a199e687
  - Что будет если вызвать тяжелую функциб внутри async функции, но без await

- Хочется добавить
  - Сравнение callback -> promise -> async/await