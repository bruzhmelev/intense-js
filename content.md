# Содержание

- Содержание
  
  - Краткий обзор.
    - Что такое JavaScript?
      - Изначально создавался для того, чтобы "оживить" web-странички.
      - JavaScript может выполняться не только в браузере, а где угодно, браузер лишь один из возможных Runtime-environment, нужна лишь специальная программа – интерпретатор.
      - Во все основные браузеры встроен интерпретатор JavaScript (движок).
    - Что умеет JavaScript? (не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется.Что же касается остальных возможностей – они зависят от окружения, в котором запущен JavaScript)
    - Что НЕ умеет JavaScript? (JavaScript – мощный язык, но браузер, когда JS работает в его окружении, накладывает на его исполнение некоторые ограничения… Этих ограничений нет на сервере NodeJS. Доп. разрешения в браузере можно получить с помощью плагинов или расширений)
    - Примеры ограничений в браузере:
      - на работу с файлами
      - на взаимодействия между вкладками
      - запросы на другой домен
    - В чём уникальность JavaScript?
      - Полная интеграция с HTML/CSS.
      - Поддерживается всеми распространёнными браузерами и включён по умолчанию.
  
  - Как работает движок JS (на примере Google V8). Ну и про стек.
    - Статья http://jem-space.ru/kak-rabotaiet-javascript/ или она же https://habr.com/ru/company/ruvds/blog/337042/
    - Движок JavaScript. Механизм состоит из двух основных компонентов:
      - ![только движок](https://i.imgur.com/DXx3GFx.png)
      - Memory Heap - здесь происходит выделение памяти;
      - Call Stack - именно там находятся кадры стека при выполнении кода.
    - The Runtime. Практически каждый разработчик JavaScript использует браузерные API (например, «setTimeout»). Однако, эти API не предоставляются движком.
      - ![полная схема, как выглядит взаимодействие движка со всем остальным](https://i.imgur.com/kFkIDpj.png)
      - Итак, у нас есть движок, но на самом деле гораздо больше - такие вещи, как веб-API, которые предоставляются браузерами: DOM, AJAX, setTimeout и многие другие. А еще, у нас есть популярный event loop и колбек очередь (callback queue).
    - Стек вызовов
      - JavaScript - это однопоточный язык программирования, что означает, что он имеет один стек вызовов. Поэтому он может делать одну вещь за раз.
      - Стек вызовов - это структура данных, которая в основном записывает, где мы находимся в программе. Если мы переходим в функцию, мы помещаем ее на вершину стека. Если мы возвращаемся из функции, мы выскочим из верхней части стека. Это все, что может делать стек.
      - Пример 1.
        ```js
        function multiply(x, y) {
            return x * y;
        }
        function printSquare(x) {
            var s = multiply(x, x);
            console.log(s);
        }
        printSquare(5);
        ```
      - Когда движок начнет выполнять этот код, стек вызовов будет пуст. После этого шаги будут следующими:
        - Картинка ![Call Stack 1](https://i.imgur.com/Prf8QbG.png)
      - Каждая запись в стеке вызовов называется кадром стека (Stack Frame).
        И именно так строится стек трейс, когда генерируется исключение - в основном это состояние стека вызовов, в момент когда оно произошло. Взгляните на следующий код:
      - Пример 2.
        ```js
        function foo() {
            throw new Error('Error message');
        }
        function bar() {
            foo();
        }
        function start() {
            bar();
        }
        start();
        ```
      - ![рис. Error with stack-trace](https://i.imgur.com/LnMzFYB.png)
      - «Blowing the stack» - происходит, когда вы достигаете максимального размера стека вызовов. Это может произойти довольно легко, например, при использовании рекурсии без тщательного тестирования кода. Посмотрите на пример:
        - Пример 3.
          ```js
          function foo() {
              foo();
          }
          foo();
          ```
        - Движок начинает выполнение кода с вызова функции «foo». Однако, эта функция, является рекурсивной и начинает вызывать себя без каких-либо условий завершения. Таким образом, на каждом этапе выполнения, одна и та же функция снова и снова добавляется в стек вызовов. Это выглядит примерно так:
          - ![Blowing the stack](https://i.imgur.com/R1TyXO1.png)
        - В какой-то момент, количество вызовов функций в стеке вызовов превышает фактический размер стека вызовов, и браузер решает предпринять действия, выдавая ошибку, которая может выглядеть примерно так:
          - ![Error max call stack size](https://i.imgur.com/AnaIkQV.png)

  - Параллелизм и Event Loop, Callback Queue. Асинхронность.
    - Статья. https://habr.com/ru/company/ruvds/blog/340508/
    - Ограничения однопоточной модели выполнения кода
      - ![вкладка не отвечает](https://i.imgur.com/SYF7cJx.png)
      - Представьте себе сложный алгоритм обработки изображений, реализация которого запускается в браузере. Когда в стеке вызовов есть работающая функция, браузер не может делать больше ничего. Он заблокирован.
      - Как только браузер начинает выполнять слишком много задач, он может достаточно продолжительное время не реагировать на воздействия пользователя.
      - Как же быть, если хочется, чтобы веб-приложение и выглядело хорошо, и могло выполнять сложные вычисления?
    - Изучение цикла событий
      - Это может показаться странным, но до ES6 JavaScript, несмотря на то, что он позволял выполнять асинхронные вызовы (вроде вышеописанного setTimeout), не содержал встроенных механизмов асинхронного программирования. JS-движки занимались только однопоточным выполнением неких фрагментов кода, по одному за раз.
        - ![полная схема, как выглядит взаимодействие движка со всем остальным](https://i.imgur.com/kFkIDpj.png)
        - Есть и другие, служебные потоки, например, для сетевых коммуникаций. Но управлять служебными потоками мы не можем. Ими управляет браузер.
      - В реальности движок не работает в изоляции — его собственный код выполняется внутри некоего окружения, которым, для большинства разработчиков, является либо браузер, либо Node.js
      - Общей характеристикой всех подобных сред является встроенный механизм, который называется циклом событий (event loop). Он поддерживает выполнение фрагментов программы, вызывая для этого JS-движок.
      - Это означает, что движок можно считать средой выполнения любого JS-кода, вызываемой по требованию. А планированием событий (то есть — сеансов выполнения JS-кода) занимаются механизмы окружения, внешние по отношению к движку.
      - Итак, например, когда ваша программа выполняет Ajax-запрос для загрузки каких-то данных с сервера, вы пишете команду для записи этих данных в переменную response внутри коллбэка, и JS-движок сообщает окружению: «Послушай, я собираюсь приостановить выполнение программы, но когда ты закончишь выполнять этот сетевой запрос и получишь какие-то данные, пожалуйста, вызови этот коллбэк».
      - Затем браузер устанавливает прослушиватель, ожидающий ответ от сетевой службы, и когда у него есть что-то, что можно возвратить в программу, выполнившую запрос, он планирует вызов коллбэка, добавляя его в Callback Queue.
      - Взгляните на следующую схему: ![полная схема](https://i.imgur.com/kFkIDpj.png)
      - А что представляют собой Web API? В целом, это — потоки, к которым у нас нет прямого доступа, мы можем лишь выполнять обращения к ним. Они встроены в браузер, где и выполняются асинхронные действия.
      - Если вы разрабатываете под Node.js, то подобные API реализованы средствами С++.
      - Что же такое Event Loop?
      - ![Event Loop + Callback Queue](https://i.imgur.com/p8dmsnW.png)
      - Event Loop решает одну основную задачу: наблюдает за стеком вызовов (call stack) и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие(callback) из очереди и помещает его в стек, что приводит к запуску этого события(callback) на выполнение.
      - Подобная итерация называется тиком (tick) Event Loop. Каждое событие — это просто коллбэк.
      - Рассмотрим следующий пример:
      ```js
          console.log('Hi');
          setTimeout(function cb1() {
              console.log('cb1');
          }, 5000);
          console.log('Bye');
      ```
      - Займёмся пошаговым «выполнением» этого кода и посмотрим, что при этом происходит в системе.
        - По шагам
          1. Пока ничего не происходит. Консоль браузера чиста, стек вызовов пуст. 
          2. ![рис](https://i.imgur.com/fCT3MC2.png)
          3. Команда console.log('Hi') добавляется в стек вызовов. ![рис](https://i.imgur.com/YgN6Z6i.png)
          4. Команда console.log('Hi') выполняется. ![рис](https://i.imgur.com/DD2Wjbp.png)
          5. Команда console.log('Hi') удаляется из стека вызовов. ![рис](https://i.imgur.com/b6wJI4q.png)
          6. Команда setTimeout(function cb1() { ... }) добавляется в стек вызовов. ![рис](https://i.imgur.com/MVvU75x.png)
          7. Команда setTimeout(function cb1() { ... }) выполняется. Браузер создаёт таймер, являющийся частью Web API. Он будет выполнять обратный отсчёт времени. ![рис](https://i.imgur.com/dEamvY3.png)
          8. Команда setTimeout(function cb1() { ... }) завершила работу и удаляется из стека вызовов. ![рис](https://i.imgur.com/Be5fINg.png)
          9. Команда console.log('Bye') добавляется в стек вызовов. ![рис](https://i.imgur.com/K2M6EQ3.png)
          10. Команда console.log('Bye') выполняется. ![рис](https://i.imgur.com/tVKUbV3.png)
          11. Команда console.log('Bye') удаляется из стека вызовов. ![рис](https://i.imgur.com/kTetVTc.png)
          12. После того, как пройдут, как минимум, 5000 мс., таймер завершает работу и помещает коллбэк cb1 в очередь коллбэков. ![рис](https://i.imgur.com/LE7t08x.png)
          13. Цикл событий берёт c функцию cb1 из очереди коллбэков и помещает её в стек вызовов. ![рис](https://i.imgur.com/WsbTA32.png)
          14. Функция cb1 выполняется и добавляет console.log('cb1') в стек вызовов. ![рис](https://i.imgur.com/WTvloc5.png)
          15. Команда console.log('cb1') выполняется. ![рис](https://i.imgur.com/Yw7b1C4.png)
          16. Команда console.log('cb1') удаляется из стека вызовов. ![рис](https://i.imgur.com/25AS2IK.png)
          17. Функция cb1 удаляется из стека вызовов. ![рис](https://i.imgur.com/BXnVbnT.png)
      - gif. ![Как работает callback queue](https://i.imgur.com/BQamRr1.gif)
      - В них можно найти рекомендацию по использованию команды setTimeout(callback, 0). Теперь вы знаете, как работает цикл событий и что происходит при вызове setTimeout. Учитывая это, вполне очевидно то, что вызов setTimeout со вторым аргументом, равным 0, просто откладывает вызов коллбэка до момента очищения стека вызовов.
    - Примечание. Вложенные (синхронные) события.
      - Обычно возникающие события «становятся в очередь».
      - Но в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.
      - [рис. Вложенные (синхронные) события]
      - Делаем события асинхронными через setTimeout(…,0)
        - можно запланировать text.focus() чуть позже через setTimeout(..., 0)
        ```js
            setTimeout(function() {
              text.focus(); // сработает после onclick
            }, 0);
        ```
      - Так событие попадёт в очередь и обработается асинхронно, как только до него дойдёт очередь.
      - Чтобы сделать событие гарантированно асинхронным, используется вызов через `setTimeout(func, 0)`.
    - Почитать дополнительно.
      - Какие теперь появились возможности в ES6
        - `но до ES6 JavaScript, несмотря на то, что он позволял выполнять асинхронные вызовы (вроде вышеописанного setTimeout), не содержал встроенных механизмов асинхронного программирования. JS-движки занимались только однопоточным выполнением неких фрагментов кода`
      - Существует спецификация Web Workers, которая позволяет запускать дополнительные JavaScript-процессы(workers). Они могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе. Такие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно.

  - Тенденции развития
    - HTML 5/5.1/5.2/5.3(Working Draft). Стандарт HTML 5 принёс много, но прогресс идёт и выпускаются 5.1/5.2/5.3(Working Draft)
      - (Тенденция: JavaScript становится всё более и более мощным и возможности браузера растут в сторону десктопных приложений.)
      - Проверяем поддержку HTML 5.X на caniuse
      - Полифиллы хороши тем, что мы просто подключаем их и используем везде современный DOM/JS, а когда старые браузеры окончательно отомрут – просто выкинем полифилл, без изменения кода. Почитать про полифилы https://learn.javascript.ru/dom-polyfill
      - Ищем полифилы на время интеграции во все браузеры, например https://github.com/GoogleChrome/dialog-polyfill
      - Где искать полифилы http://html5please.com/#polyfill и при этом можно почитать в какой стадии поддержки та или иная фича HTML5
      - Ещё список полифилов HTML5 - https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills
    - ECMAScript 6+
      - ECMAScript - это спецификация на основе которой работает язык JS. Выход спецификации ECMAScript 6 принёс самые большие изменения в язык в 2015 году и стех пор с темпом раз в год выпускаются новые спецификации ES7, ES8, ES9
      - Часто браузеры внедряют фичи заранее из ещё разрабатываемого стандарта и он может поменяться, поэтому лучше всегда брать только те фичи по которым стандарт уже принят или находится на последней стадии `stage-4`.
      - Помните, что этот функционал добавляется в язык неспроста. Причины, по которым умные люди из TC39 это делают — улучшение качества языка, абстрагирования, удобства пользования и другие. Изучите эти новшества заранее, и к тому моменту, как они будут официально опубликованы и станут везде поддерживаться, вы сможете не теряя времени сразу приняться за работу.
      - Ссылка на спецификацию https://tc39.github.io/ecma262/ (репо: https://github.com/tc39/ecma262)
      - Текущая поддержка браузерами фич из каждой спецификации http://kangax.github.io/compat-table/es2016plus/
      - Текущие proposals https://github.com/tc39/proposals
        - Какие стадии у каждого proposal и сам процесс продвижения https://tc39.github.io/process-document/ (см. колонку Acceptance Signifies, например для stage-4 это `The addition will be included in the soonest practical standard revision`)

    - Как попробовать новые фичи.
      - ES6+ прямо сейчас с помощью babel
      - TypeScript
    - Языки поверх JavaScript, компилятся в JS (TS, Dart, CoffeeScript, flowtype, ...)
    - Тенденция: JavaScript становится всё быстрее и стабильнее, в язык добавляются новые возможности.
    - Тенденция: всё идет к полной совместимости со стандартом. В разных браузерах разная степень отставания в имплементации стандартов.
    - Отдельно рассмотрим фичи ES6+ в последней части.

- Особенности JavaScript (мелкие тонкости) [сокращаю]
  - Типы.
    - Есть 5 «примитивных» типов и объекты:
      - ![5 «примитивных» типов](https://i.imgur.com/3xc7ndF.png)
  - Особенности операторов.
    - Сложения.
      - Если хоть один аргумент – строка, то другой тоже приводится к строке.
    - Сравнение.
      - Сравнение === проверяет точное равенство, включая одинаковый тип.
      - Остальные сравнения == < <= > >= осуществляют числовое приведение типа.
      - Исключение – сравнение двух строк, которое осуществляется лексикографически. Символы сравниваются по своим unicode-кодам.
      - Также: значения null и undefined при == равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение null к 0, а undefined к NaN.
    - Логические операторы
      - Как и в большинстве других языков, в логических операторах используется «короткий цикл» вычислений. Например, вычисление выражения 1 && 0 && 2 остановится после первого И &&, т.к. понятно что результат будет ложным (ноль интерпретируется как false).
      - Результатом логического оператора служит последнее значение в коротком цикле вычислений. Значения хоть и интерпретируются как логические, но то, которое в итоге определяет результат, возвращается без преобразования.
    - Числа (наверное лишнее)
      - Деление на ноль, Infinity
      - NaN (Если математическая операция не может быть совершена, то возвращается специальное значение NaN. Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.)
  - Кратко прочитать здесь: https://learn.javascript.ru/javascript-specials

- Важное для понимания в JavaScript (высокоуровнево как работает)
  
  - Замыкания, область видимости
    - Замыкания
      - Глобальный объект
        - В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект»
        - В результате инициализации, к началу выполнения кода:
          - Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.
          - Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них.
      - Лексическое окружение
        - Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.
        - При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
        - В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
      - Доступ ко внешним переменным
        - Каждая функция при создании получает ссылку [[Scope]] на объект с переменными LexicalEnvironment, в контексте которого была создана.
        - При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он получает ссылку на внешний объект переменных из [[Scope]].
        - Интерпретатор, при поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.
      - Что такое замыкание
        - Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
        - То есть, замыкание – это функция + внешние переменные.
        - Тем не менее, в JavaScript есть небольшая терминологическая особенность.
        - Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.
        - Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.
      - «Понимать замыкания» в JavaScript означает понимать следующие вещи:
        - Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
        - При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
        - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
  
  - В следствие, из понимания LexicalEnvironment можно легко понять разницу в поведении Function Declaration и Expression и то, что называется Поднятие(Hoisting)
    - Function Declaration и Expression
      - Синтаксис, при котором функция объявляется в контексте выражения (например, выражение присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода – Function Declaration.
      - Функции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.
    - Поднятие (hoisting)
      - Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации. JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после ее использования, то значение будет undefined.
    - Подробнее описание здесь https://learn.javascript.ru/functions-closures
  
  - Контекст вызова
    - Методы объектов, this
      - Контекст есть у ВЫЗОВА функции!!!! А не у самой функции. Нужно помнить наизусть 4 случая использования this:
        1. Простой вызов функции вне объекта
             Foo();
             // undefined (если при use strict)
             // window - при старом стандарте
        2. Вызов метода объекта
             Контестом становится то что слева от функции.
             Совершенно не важно где функция была объявлена - ГЛАВНОЕ - на каком объекте была вызвана через точку и т.п.
             [картинка с примером]
        3. Заранее известный контекст (call, apply, bind)
             Apply - нужен для того, чтобы вызвать функцию на заранее установленном контексте.
             Первым аргументом у apply будет контекст на котором вызвать данную функцию.
             Аргументы в данном случае нужно передавать в массиве вторым аргументом.
             Call – абсолютно аналогично apply только передавать аргументы можно через запятую
             Bind - аналогично call и apply привязывает контекст, но не вызывает функцию, а возвращает функцию с привязанным контекстом.
        4. Создание объектов через конструктор "new"
             Любую функцию можно вызвать с ключевым словом NEW. Тогда результатом будет объект this, даже если явно его не вернуть. Если возвращать примитив, тогда он проигнориется и всё равно вернется this;
        - Стрелочные функции (ES6)
    - Функции-обёртки, декораторы - https://learn.javascript.ru/decorators
  

  - Промисы, в сравнении с callback. [Но какую интересную суть объяснения промисов вытащить не понятно. Надо искать в другом месте.] [дописать]
    - [Очень коротко о промисах, что из себя представляют.]
    - Обработка неперехваченных исключений
      ```js
      .done(null, function() {
          // если здесь произойдёт исключение, оно попадёт в глобальную область видимости
      });
      ```
  - ES8: async / await
    - В JavaScript ES8 появилась конструкция async / await, которая упрощает работу с промисами.
    - Асинхронные функции объявляют, пользуясь ключевым словом async. Такая функция возвращает объект AsyncFunction. Этот объект представляет собой асинхронную функцию, которая выполняет код, находящийся внутри неё.
    - Когда асинхронная функция вызывается, она возвращает объект Promise. Если такая функция возвращает значение, которое не является объектом Promise, этот объект будет автоматически создан и разрешён с использованием значения, возвращённого функцией. Если функция, объявленная с ключевым словом async, выдаст исключение, промис будет отклонён с этим исключением.
    - Функция, объявленная с ключевым словом async, может содержать выражение с ключевым словом await, которое приостанавливает выполнение функции и ожидает разрешения промиса, фиругирующего в данном выражении. После этого выполнение async-функции продолжается, и, например, осуществляется возврат полученного после разрешения промиса значения.
    - Объекты Promise в JavaScript можно рассматривать как эквиваленты Future из Java или Task из C#.
    - Цель async / await заключается в том, чтобы упростить использование промисов.
    - Ключевое слово await можно использовать только в функциях, объявленных с ключевым словом async. Оно позволяет организовать ожидание разрешения промиса. Если мы используем промисы за пределами async-функций, нам всё ещё нужно использовать коллбэки блока then:
      - рис. [Ключевое слово await можно использовать только в функциях, объявленных с ключевым словом async]
    - 5 советов по написанию надёжного асинхронного кода, который легко поддерживать
      - Прямо из статьи уже сделать слайды. Т.к. уже и так много. https://habr.com/ru/company/ruvds/blog/340508/
      - Чистота кода. Использование конструкции async / await позволяет вам писать гораздо меньше кода.
      - Обработка ошибок. Конструкция async / await позволяет обрабатывать синхронные и асинхронные ошибки с использованием одних и тех же механизмов. А именно, речь идёт о широко известном выражении try / catch.
      - Обработка условий. Применение async / await упрощает написание кода, использующего условия. Вот — код, основанный на промисах:
      - Трассировка стека. В отличие от async / await, стек ошибки, возвращённый из цепочки промисов, не содержит сведений о точном месте, в котором произошла ошибка.
  
  - DOM
    - Окружение: DOM, BOM и JS
      - Сам по себе язык JavaScript не предусматривает работы с браузером. Он вообще не знает про HTML. Но позволяет легко расширять себя новыми функциями и объектами.
      - На рисунке ниже схематически отображена структура, которая получается если посмотреть на совокупность браузерных объектов
        - ![совокупность браузерных объектов](https://i.imgur.com/yQGgBrN.png)
      - Объектная модель браузера (BOM)
        - BOM – это объекты для работы с чем угодно, кроме документа.
        - Например:
          - Объект navigator содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства: navigator.userAgent – содержит информацию о браузере и navigator.platform – содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.
          - Объект location содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.
          - Функции alert/confirm/prompt – тоже входят в BOM.
    - DOM – это представление документа в виде дерева объектов, доступное для изменения через JavaScript.
      - рис. [Пример DOM]
      - Всё, что есть в HTML, находится и в DOM.
      - Даже директива <!DOCTYPE...>, которую мы ставим в начале HTML, тоже является DOM-узлом, и находится в дереве DOM непосредственно перед <html>. На иллюстрациях выше этот факт скрыт, поскольку мы с этим узлом работать не будем, он никогда не нужен.
      - Даже сам объект document, формально, является DOM-узлом, самым-самым корневым.
    - Возможности, которые дает DOM
      - DOM нужен для того, чтобы манипулировать страницей – читать информацию из HTML, создавать и изменять элементы.
      - У элементов DOM есть свойства и методы, которые позволяют изменять их.
    - Поиск: getElement* и querySelector* и не только
      - document.getElementById или просто id - Если элементу назначен специальный атрибут id, то можно получить его прямо по переменной с именем из значения id.
      - общепринятой практикой является доступ к элементу вызовом document.getElementById("идентификатор")
        - ![getElementById](https://i.imgur.com/L5VFk8V.png)
      - По стандарту значение id должно быть уникально, то есть в документе может быть только один элемент с данным id
      - Также есть 
        - getElementsByTagName - ищет все элементы с заданным тегом tag внутри элемента elem и возвращает их в виде списка.
        - document.getElementsByName - позволяет получить все элементы с данным атрибутом name.
        - getElementsByClassName - возвращает коллекцию элементов с классом className
        - querySelectorAll - возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css.
        - querySelector - возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
        - matches - ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false.
        - closest - ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.
        - Итого - Есть 6 основных методов поиска элементов DOM:
          - ![6 основных методов поиска](https://i.imgur.com/qXVjVLY.png)
        - Практика показывает, что в 95% ситуаций достаточно querySelector/querySelectorAll. Хотя более специализированные методы getElement* работают чуть быстрее, но разница в миллисекунду-другую редко играет роль.
        - Если нужно найти один элемент используйте `querySelector()`, а не `querySelectorAll(...)[0]`, т.к. querySelectorAll будет искать до конца документа и потом только выберет первый элемент. А querySelector остановится на первом.
      - Изменение
        ```js
            parent.appendChild(newChild);
            parent.removeChild(child);
            parent.insertBefore(newChild, refNode);
            parent.insertAdjacentHTML("beforeBegin|afterBegin|beforeEnd|afterEnd", html);
            parent.insertAdjacentElement("beforeBegin|...|afterEnd", element) (кроме FF);
            parent.insertAdjacentText("beforeBegin|...|afterEnd", text) (кроме FF);
            document.write(...);
            node.append(...nodes);
            node.prepend(...nodes);
            node.after(...nodes);
            node.before(...nodes);
            node.replaceWith(...nodes);
        ```
  
  - Основы работы с событиями.
    - Для реакции на действия посетителя и внутреннего взаимодействия скриптов существуют события.
      - Событие – это сигнал от браузера о том, что что-то произошло. Существует много видов событий. Посмотрим список самых часто используемых, пока просто для ознакомления:
      - ![Для слайда. Скопировать c сайта](https://i.imgur.com/4705yHy.png) 
      - Для слайда. Скопировать c сайта https://learn.javascript.ru/introduction-browser-events
    - Назначение обработчиков событий
      - Событию можно назначить обработчик(callback), то есть функцию, которая сработает, как только событие произошло.
      - Использование атрибута HTML
        - ![onclick](https://i.imgur.com/kkvyM1R.png)
      - Использование свойства DOM-объекта
        - ![elem.onclick](https://i.imgur.com/VsxlUZj.png)
      - Так как DOM-свойство onclick, в итоге, одно, то назначить более одного обработчика так нельзя.
      - Методы addEventListener и removeEventListener являются предпочитаемым способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков.
        - ![addEventListener](https://i.imgur.com/nz9eUSK.png)
        - ![removeEventListener](https://i.imgur.com/7Dv3DG0.png)
        - Удаление требует именно ту же функцию. Для удаления нужно передать именно ту функцию-обработчик которая была назначена.
        - Если функцию не сохранить где-либо, а просто передать в addEventListener, как в предыдущем коде, то потом получить её обратно, чтобы снять обработчик, будет невозможно.
    - Объект события
      - event.type
      - event.currentTarget
      - event.clientX / event.clientY
      - Есть также и ряд других свойств, в зависимости от событий,
    - Всплытие и перехват
      - Всплытие
        - Этот обработчик для `<div>` сработает, если вы кликните по вложенному тегу `<em>` или `<code>`:
        - ![Всплытие](https://i.imgur.com/g8IK6gB.png)
        - При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.
        - Всплытие гарантирует, что клик по внутреннему <p> вызовет обработчик onclick (если есть) сначала на самом <p>, затем на элементе <div> далее на элементе <form>, и так далее вверх по цепочке родителей до самого document.
        - ![Визуализация всплытия](https://i.imgur.com/l6fZRiv.png)
        - Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как event.target.
        - Например, если стоит только один обработчик form.onclick, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента <form>, на котором сработает обработчик.
      - Прекращение всплытия
        - Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента <html>, а затем до document, вызывая все обработчики на своем пути.
        - Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
        - Для остановки всплытия нужно вызвать метод `event.stopPropagation()`.
        - ![stopPropagation](https://i.imgur.com/6JzIPTI.png)
        - Не прекращайте всплытие без необходимости!
          - Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.
          - Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.
      - Погружение
        - В современном стандарте, кроме «всплытия» событий, предусмотрено ещё и «погружение».
        - Оно гораздо менее востребовано, но иногда, очень редко, знание о нём может быть полезным.
        - Строго говоря, стандарт выделяет целых три стадии прохода события:
          - ![три стадии прохода события](https://i.imgur.com/Sd40X9r.png)
          - Событие сначала идет сверху вниз. Эта стадия называется «стадия перехвата» (capturing stage).
          - Событие достигло целевого элемента. Это – «стадия цели» (target stage).
          - После этого событие начинает всплывать. Это – «стадия всплытия» (bubbling stage).
        - Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.
        - Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener:
          - Если аргумент true, то событие будет перехвачено по дороге вниз.
          - Если аргумент false, то событие будет поймано при всплытии.
      - Приём проектирования "поведение"
        - Шаблон проектирования «поведение» (behavior) позволяет задавать хитрые обработчики на элементе декларативно, установкой специальных HTML-атрибутов и классов.
        - Приём проектирования «поведение» состоит из двух частей: 
          - Элементу ставится атрибут, описывающий его поведение.
          - При помощи делегирования ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.
          - Пример
            - Например, добавим «поведение», которое всем элементам, у которых стоит атрибут data-counter, будет при клике увеличивать значение на 1:
            - ![Пример](https://i.imgur.com/wg62aZw.png)
  
  - Современный JS (ES6+)
    - Что основного добавил ES6
      - сlasses and modules
      - iterators and for/of loops
      - Python-style generators
      - arrow functions
      - binary data
      - typed arrays
      - collections (maps, sets and weak maps)
      - promises
      - number and math enhancements
      - reflection
      - and proxies (metaprogramming for virtual objects and wrappers)
      - and many others
    - ES7 (ECMAScript 2016)
      - exponentiation operator (`**`)
      - Array.prototype.includes
    - ES8 (ECMAScript 2017)
      - async/await, which works using generators and promises
    - ES9 (ECMAScript 2018)
      - rest/spread properties
      - asynchronous iteration
      - Promise.prototype.finally()
      - additions to RegExp
    - ES.Next - features are more correctly called proposals, because, by definition, the specification has not been finalized yet

- Источники
  - http://jem-space.ru/kak-rabotaiet-javascript/
  - https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e
  - Цикл статей.
    - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await https://habr.com/ru/company/ruvds/blog/340508/
    - Как работает JS: обзор движка, механизмов времени выполнения, стека вызовов https://habr.com/ru/company/ruvds/blog/337042/
- Ссылки
  - https://babeljs.io/docs/en/learn.html
  - Просто про DOM https://learn.javascript.ru/document
  - Почитать про DOM-полифилы https://learn.javascript.ru/dom-polyfill

- Важно знать. Что ещё почитать в порядке важности:
  - AJAX(XMLHttpRequest) и fetch
  - Прототипы
  - Преобразование типов для примитивов

- Дополнительно
  - LocalStorage
  - WebWorkers
  - ServiceWorkers

- На будущее
  - Может получиться очень хороший рассказ о том как работает JS(движок и вещи рядом) на основе картинки взаимодействия движка с WebApi(document, XHR, setTimeout) и с EventLoop + CallbackQueue(onClick, onLoad, onDone), опираясь на цикл статей.