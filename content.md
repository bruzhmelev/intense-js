# Содержание

- Краткий обзор
  - Что такое JavaScript? (оживление страничек, интерпретаторы, браузер ...)
  - Что умеет JavaScript? (не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется.Что же касается остальных возможностей – они зависят от окружения, в котором запущен JavaScript)
  - Что НЕ умеет JavaScript? (JavaScript – быстрый и мощный язык, но браузер накладывает на его исполнение некоторые ограничения… Этих ограничений нет на сервере. Также плагины и расширения дают доп. разрешения)
    Ограничения: - в работе с файлами - на взаимодействия между вкладками - запросы на другой домен
  - В чём уникальность JavaScript?
    - Полная интеграция с HTML/CSS.
    - Простые вещи делаются просто.
    - Поддерживается всеми распространёнными браузерами и включён по умолчанию.
  - Тенденции развития
    - HTML 5/5.1/5.2/5.3(Working Draft)
      - здесь можно перечислить возможности, о которых важно знать.
      - (Тенденция: JavaScript становится всё более и более мощным и возможности браузера растут в сторону десктопных приложений.)
      - проверяем поддержку HTML 5.X на caniuse
      - ищем полифилы на время интеграции во все браузеры, например https://github.com/GoogleChrome/dialog-polyfill
      - где искать полифилы http://html5please.com/#polyfill и при этом можно почитать в какой стадии поддержки та или иная фича HTML5
      - ещё список полифилов HTML5 - https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills
    - ECMAScript 6+
      - Часто браузеры внедряют фичи заранее из ещё разрабатываемого стандарта и он может поменяться, поэтому лучше всегда брать только те фичи по которым стандарт уже принят или находится на последней стадии.
      - Помните, что этот функционал добавляется в язык неспроста. Причины, по которым умные люди из TC39 это делают — улучшение качества языка, абстрагирования, удобства пользования и другие. Изучите эти новшества заранее, и к тому моменту, как они будут официально опубликованы и станут везде поддерживаться, вы сможете не теряя времени сразу приняться за работу.
      - Где почитать текущую спецификацию https://tc39.github.io/ecma262/ (репо: https://github.com/tc39/ecma262)
      - Посмотреть текущую поддержку браузерами фич из каждой спецификации http://kangax.github.io/compat-table/es2016plus/
      - Посмотреть текущие proposals https://github.com/tc39/proposals
        - Какие стадии у каждого proposal и сам процесс продвижения https://tc39.github.io/process-document/ (см. колонку Acceptance Signifies, например для stage-4 это `The addition will be included in the soonest practical standard revision`)
      - Как попробовать новые фичи.
        - babel
          - раньше можно было подключить preset `stage-0`, теперь отказались в сторону явного подключения каждого proposal в проект. (Пример) https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0
          - Также отказались от единого полифила, в который входили и полифилы proposals в сторону разделения `import "@babel/polyfill"`
            - теперь `import "core-js/shim"; // included < Stage 4 proposals`
            - Below is a list of Stage < 3 proposal polyfills in core-js v2.
              - https://babeljs.io/docs/en/v7-migration#remove-proposal-polyfills-in-babel-polyfill-https-githubcom-babel-babel-issues-8416
      - Тенденция: JavaScript становится всё быстрее и стабильнее, в язык добавляются новые возможности.
      - Тенденция: всё идет к полной совместимости со стандартом. В браузерах всё ещё есть кое какие не совместимости.
      - Отдельно рассмотрим фичи ES6+ в последней части.
  - Языки поверх JavaScript, компилятся в JS (TS, Dart, CoffeeScript, flowtype, ...)
  - ES6+ прямо сейчас с помощью babel
- Особенности JavaScript (тонкости) [сокращаю]
  - Типы. Просто напомнить какие есть.
  - Особенности операторов
    - Сложения
      - Если хоть один аргумент – строка, то другой тоже приводится к строке
    - Сравнение
      - Сравнение === проверяет точное равенство, включая одинаковый тип
      - Остальные сравнения == < <= > >= осуществляют числовое приведение типа
      - Исключение – сравнение двух строк, которое осуществляется лексикографически. Символы сравниваются по своим unicode-кодам.
      - Также: значения null и undefined при == равны друг другу и не равны ничему ещё. А при операторах больше/меньше происходит приведение null к 0, а undefined к NaN.
    - Логические операторы
      - Как и в большинстве других языков, в логических операторах используется «короткий цикл» вычислений. Например, вычисление выражения 1 && 0 && 2 остановится после первого И &&, т.к. понятно что результат будет ложным (ноль интерпретируется как false).
      - Результатом логического оператора служит последнее значение в коротком цикле вычислений. Значения хоть и интерпретируются как логические, но то, которое в итоге определяет результат, возвращается без преобразования.
    - Числа (наверное лишнее)
      - Деление на ноль, Infinity
      - NaN (Если математическая операция не может быть совершена, то возвращается специальное значение NaN. Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.)
- Важное для понимания в JavaScript (высокоуровнево как работает)
  - Замыкания, область видимости
    - Замыкания
      - Глобальный объект
        - В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект»
        - В результате инициализации, к началу выполнения кода:
          - Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.
          - Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них.
      - Лексическое окружение
        - Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.
        - При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
        - В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
      - Доступ ко внешним переменным
        - Каждая функция при создании получает ссылку [[Scope]] на объект с переменными LexicalEnvironment, в контексте которого была создана.
        - При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он получает ссылку на внешний объект переменных из [[Scope]].
        - Интерпретатор, при поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.
      - Что такое замыкание
        - Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
        - То есть, замыкание – это функция + внешние переменные.
        - Тем не менее, в JavaScript есть небольшая терминологическая особенность.
        - Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.
        - Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.
      - «Понимать замыкания» в JavaScript означает понимать следующие вещи:
        - Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.
        - При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана.
        - При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
  - В следствие, из понимания LexicalEnvironment можно легко понять разницу в поведении Function Declaration и Expression и то, что называется Поднятие(Hoisting)
    - Function Declaration и Expression
      - Синтаксис, при котором функция объявляется в контексте выражения (например, выражение присваивания), называется Function Expression, а обычный синтаксис, при котором функция объявляется в основном потоке кода – Function Declaration.
      - Функции, объявленные через Function Declaration, отличаются от Function Expression тем, что интерпретатор создаёт их при входе в область видимости (в начале выполнения скрипта), так что они работают до объявления.
    - Поднятие (hoisting)
      - Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации. JavaScript "поднимает" только объявление, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после ее использования, то значение будет undefined.
  - Если чувствуете неуверенность в данном вопросе, рекомендую почитать хорошее, подробное описание здесь https://learn.javascript.ru/functions-closures
  - Контекст вызова
    - Методы объектов, this
      - Контекст есть у ВЫЗОВА функции!!!! А не у самой функции. Нужно помнить наизусть 4 случая использования this:
        1. Простой вызов функции вне объекта
             Foo();
             // undefined (если при use strict)
             // window - при старом стандарте
        2. Вызов метода объекта
             Контестом становится то что слева от функции.
             Совершенно не важно где функция была объявлена - ГЛАВНОЕ - на каком объекте была вызвана через точку и т.п.
             [картинка с примером]
        3. Заранее известный контекст (call, apply, bind)
             Apply - нужен для того, чтобы вызвать функцию на заранее установленном контексте.
             Первым аргументом у apply будет контекст на котором вызвать данную функцию.
             Аргументы в данном случае нужно передавать в массиве вторым аргументом.
             Call – абсолютно аналогично apply только передавать аргументы можно через запятую
             Bind - аналогично call и apply привязывает контекст, но не вызывает функцию, а возвращает функцию с привязанным контекстом.
        4. Создание объектов через конструктор "new"
             Любую функцию можно вызвать с ключевым словом NEW. Тогда результатом будет объект this, даже если явно его не вернуть. Если возвращать примитив, тогда он проигнориется и всё равно вернется this;
        - Стрелочные функции (ES6)
    - Функции-обёртки, декораторы - https://learn.javascript.ru/decorators
  - Контекст выполнения, стек [убрать в пользу следующего описания, либо кратко перенести недостающие детали во вторую]
    - У каждого вызова функции есть свой «контекст выполнения» (execution context).
    - Контекст выполнения – это служебная информация, которая соответствует текущему запуску функции. Она включает в себя локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
    - Пример. "Степень pow(x, n) через рекурсию"
      Для `pow(2, 3)` из примера выше будет создан контекст выполнения, который будет хранить переменные x = 2, n = 3. Мы схематично обозначим его так:
      `[Контекст: { x: 2, n: 3, строка 1 }]`
      - Далее функция pow начинает выполняться.
      - требуется произвести запуск pow с новыми аргументами.
      - При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов».
      - Для нового вызова создаётся свой контекст выполнения, и управление переходит в него, а когда он завершён – старый контекст достаётся из стека и выполнение внешней функции возобновляется.
      - В результате нескольких циклов рекурсии имеем следующий "стек контекстов"
        [Контекст: { x: 2, n: 3, строка 3 }][контекст: { x: 2, n: 2, строка 3 }]
        [Контекст: { x: 2, n: 1, строка 1 }]
      - Когда функция заканчивает свою работу, возвращая 2. Текущий контекст больше не нужен и удаляется из памяти, из стека восстанавливается предыдущий:
      - Выход из pow(2, 2).
      - Выход из pow(2, 3).
      - Глубина рекурсии в данном случае составила: 3.
      - глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.
      - Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, в данном случае это приводит к тому, что возведение в степень n хранит в памяти n различных контекстов.
  - Стек. Как работает движок JS (Например, Google V8)
    - Статья http://jem-space.ru/kak-rabotaiet-javascript/ или она же https://habr.com/ru/company/ruvds/blog/337042/
    - Движок JavaScript. Механизм состоит из двух основных компонентов:
      - Memory Heap - здесь происходит выделение памяти;
      - Call Stack - именно там находятся кадры стека при выполнении кода.
    - The Runtime. Практически каждый разработчик JavaScript использует браузерные API (например, «setTimeout»). Однако, эти API не предоставляются движком.
      - [картинка как выглядит взаимодействие движка со всем остальным]
      - Итак, у нас есть движок, но на самом деле гораздо больше - такие вещи, как веб-API, которые предоставляются браузерами: DOM, AJAX, setTimeout и многие другие. А еще, у нас есть популярный event loop и колбек очередь (callback queue).
    - Стек вызовов
      - JavaScript - это однопоточный язык программирования, что означает, что он имеет один стек вызовов. Поэтому он может делать одну вещь за раз.
      - Стек вызовов - это структура данных, которая в основном записывает, где мы находимся в программе. Если мы переходим в функцию, мы помещаем ее на вершину стека. Если мы возвращаемся из функции, мы выскочим из верхней части стека. Это все, что может делать стек.
      - [Добавить описание и картинки для краткого описания работы стека].
      - Пример 1.
        ```js
        function multiply(x, y) {
            return x * y;
        }
        function printSquare(x) {
            var s = multiply(x, x);
            console.log(s);
        }
        printSquare(5);
        ```
      - Когда движок начнет выполнять этот код, стек вызовов будет пуст. После этого шаги будут следующими:
        - Картинка [Call Stack 1]
      - Каждая запись в стеке вызовов называется кадром стека (Stack Frame).
        И именно так строится стек трейс, когда генерируется исключение - в основном это состояние стека вызовов, в момент когда оно произошло. Взгляните на следующий код:
      - Пример 2.
        ```js
        function foo() {
            throw new Error('SessionStack will help you resolve crashes :)');
        }
        function bar() {
            foo();
        }
        function start() {
            bar();
        }
        start();
        ```
      - [рис. Error with stack-trace]
      - « Blowing the stack » - происходит, когда вы достигаете максимального размера стека вызовов. Это может произойти довольно легко, например, при использовании рекурсии без тщательного тестирования кода. Посмотрите на пример:
        - Пример 3.
          ```js
          function foo() {
              foo();
          }
          foo();
          ```
        - Движок начинает выполнение кода с вызова функции «foo». Однако, эта функция, является рекурсивной и начинает вызывать себя без каких-либо условий завершения. Таким образом, на каждом этапе выполнения, одна и та же функция снова и снова добавляется в стек вызовов. Это выглядит примерно так:
          - [Blowing the stack]
        - В какой-то момент, количество вызовов функций в стеке вызовов превышает фактический размер стека вызовов, и браузер решает предпринять действия, выдавая ошибку, которая может выглядеть примерно так:
          - [Error max call stack size]
  - Callback Queue [Плохое объяснение, есть лучше ниже] [убрать]
    - Главный поток. JavaScript является однопоточным.
      - В каждом окне выполняется только один главный поток, который занимается выполнением JavaScript, отрисовкой и работой с DOM.
      - Есть и другие, служебные потоки, например, для сетевых коммуникаций. Но управлять служебными потоками мы не можем.
      - Существует спецификация Web Workers, которая позволяет запускать дополнительные JavaScript-процессы(workers). Они могут обмениваться сообщениями с главным процессом, но у них свои переменные, и работают они также сами по себе. Такие дополнительные процессы не имеют доступа к DOM, поэтому они полезны, преимущественно, при вычислениях, чтобы загрузить несколько ядер/процессоров одновременно.
    - Использует "Очередь событий" (Callback Queue).
    - Очередь событий.
      - События могут возникать не только по очереди, но и «пачкой» по много сразу. Возможно и такое, что во время обработки одного события возникают другие, например пока выполнялся код для onclick – посетитель нажал кнопку на клавиатуре (событие keydown).
      - Здесь мы посмотрим, как браузер обычно работает с одновременно возникающими событиями и какие есть исключения из общего правила.
      - Произошло одновременно несколько событий или во время обработки одного случилось другое – как главному потоку обработать это?
      - Если главный поток прямо сейчас занят, то он не может срочно выйти из середины одной функции и прыгнуть в другую.
      - Когда происходит событие, оно попадает в очередь.
      - Внутри браузера непрерывно работает «главный внутренний цикл» (Event Loop), который следит за состоянием очереди и обрабатывает события, запускает соответствующие обработчики и т.п.
      - Иногда события добавляются в очередь сразу пачкой.
      - При этом каждое событие из очереди обрабатывается полностью отдельно от других.
    - Вложенные (синхронные) события.
      - Обычно возникающие события «становятся в очередь».
      - Но в тех случаях, когда событие инициируется не посетителем, а кодом, то оно, как правило, обрабатывается синхронно, то есть прямо сейчас.
      - [рис. Вложенные (синхронные) события]
    - Делаем события асинхронными через setTimeout(…,0)
      - можно запланировать text.focus() чуть позже через setTimeout(..., 0)
      ```js
          setTimeout(function() {
            text.focus(); // сработает после onclick
          }, 0);
      ```
      - Такой вызов обеспечит фокусировку через минимальный «тик» таймера, по стандарту равный 4 мс. Обычно такая задержка не играет роли, а необходимую асинхронность мы получили.
    - Итого
      - JavaScript выполняется в едином потоке. Современные браузеры позволяют порождать подпроцессы Web Workers, они выполняются параллельно и могут отправлять/принимать сообщения, но не имеют доступа к DOM.
      - Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.
      - Синхронными являются вложенные события, инициированные из кода.
      - Чтобы сделать событие гарантированно асинхронным, используется вызов через setTimeout(func, 0).
      - Отложенный вызов через setTimeout(func, 0) используется не только в событиях, а вообще – всегда, когда мы хотим, чтобы некая функция func сработала после того, как текущий скрипт завершится.
  - Параллелизм и Event Loop, Callback Queue. [Лучшее объяснение] Async/await
    - Статья. https://habr.com/ru/company/ruvds/blog/340508/
    - Ограничения однопоточной модели выполнения кода
      - Представьте себе сложный алгоритм обработки изображений, реализация которого запускается в браузере. Когда в стеке вызовов есть работающая функция, браузер не может делать больше ничего. Он заблокирован.
      - Как только браузер начинает выполнять слишком много задач, он может достаточно продолжительное время не реагировать на воздействия пользователя.
      - Как же быть, если хочется, чтобы веб-приложение и выглядело хорошо, и могло выполнять сложные вычисления?
    - Изучение цикла событий
      - Это может показаться странным, но до ES6 JavaScript, несмотря на то, что он позволял выполнять асинхронные вызовы (вроде вышеописанного setTimeout), не содержал встроенных механизмов асинхронного программирования. JS-движки занимались только однопоточным выполнением неких фрагментов кода, по одному за раз.
      - В реальности движок не работает в изоляции — его собственный код выполняется внутри некоего окружения, которым, для большинства разработчиков, является либо браузер, либо Node.js
      - Общей характеристикой всех подобных сред является встроенный механизм, который называется циклом событий (event loop). Он поддерживает выполнение фрагментов программы, вызывая для этого JS-движок.
      - Это означает, что движок можно считать средой выполнения любого JS-кода, вызываемой по требованию. А планированием событий (то есть — сеансов выполнения JS-кода) занимаются механизмы окружения, внешние по отношению к движку.
      - Итак, например, когда ваша программа выполняет Ajax-запрос для загрузки каких-то данных с сервера, вы пишете команду для записи этих данных в переменную response внутри коллбэка, и JS-движок сообщает окружению: «Послушай, я собираюсь приостановить выполнение программы, но когда ты закончишь выполнять этот сетевой запрос и получишь какие-то данные, пожалуйста, вызови этот коллбэк».
      - Затем браузер устанавливает прослушиватель, ожидающий ответ от сетевой службы, и когда у него есть что-то, что можно возвратить в программу, выполнившую запрос, он планирует вызов коллбэка, добавляя его в цикл событий.
      - Взгляните на следующую схему: [полная схема]
      - А что представляют собой Web API? В целом, это — потоки, к которым у нас нет прямого доступа, мы можем лишь выполнять обращения к ним. Они встроены в браузер, где и выполняются асинхронные действия.
      - Цикл событий решает одну основную задачу: наблюдает за стеком вызовов и очередью коллбэков (callback queue). Если стек вызовов пуст, цикл берёт первое событие из очереди и помещает его в стек, что приводит к запуску этого события на выполнение.
      - Подобная итерация называется тиком (tick) цикла событий. Каждое событие — это просто коллбэк.
      - Рассмотрим следующий пример:
      ```js
          console.log('Hi');
          setTimeout(function cb1() {
              console.log('cb1');
          }, 5000);
          console.log('Bye');
      ```
      - Займёмся пошаговым «выполнением» этого кода и посмотрим, что при этом происходит в системе.
      - рис. [Как работает callback queue]
      - В них можно найти рекомендацию по использованию команды setTimeout(callback, 0). Теперь вы знаете, как работает цикл событий и что происходит при вызове setTimeout. Учитывая это, вполне очевидно то, что вызов setTimeout со вторым аргументом, равным 0, просто откладывает вызов коллбэка до момента очищения стека вызовов.
  - Задания ES6(Job Queue) [Не очень понятно. Нет практического примера.]
    - Та же статья. https://habr.com/ru/company/ruvds/blog/340508/
  - Промисы, в сравнении с callback. [Но какую интересную суть объяснения промисов вытащить не понятно. Надо искать в другом месте.] [дописать]
    - [Очень коротко о промисах, что из себя представляют.]
    - Обработка неперехваченных исключений
      ```js
      .done(null, function() {
          // если здесь произойдёт исключение, оно попадёт в глобальную область видимости
      });
      ```
  - ES8: async / await
    - В JavaScript ES8 появилась конструкция async / await, которая упрощает работу с промисами.
    - Асинхронные функции объявляют, пользуясь ключевым словом async. Такая функция возвращает объект AsyncFunction. Этот объект представляет собой асинхронную функцию, которая выполняет код, находящийся внутри неё.
    - Когда асинхронная функция вызывается, она возвращает объект Promise. Если такая функция возвращает значение, которое не является объектом Promise, этот объект будет автоматически создан и разрешён с использованием значения, возвращённого функцией. Если функция, объявленная с ключевым словом async, выдаст исключение, промис будет отклонён с этим исключением.
    - Функция, объявленная с ключевым словом async, может содержать выражение с ключевым словом await, которое приостанавливает выполнение функции и ожидает разрешения промиса, фиругирующего в данном выражении. После этого выполнение async-функции продолжается, и, например, осуществляется возврат полученного после разрешения промиса значения.
    - Объекты Promise в JavaScript можно рассматривать как эквиваленты Future из Java или Task из C#.
    - Цель async / await заключается в том, чтобы упростить использование промисов.
    - Ключевое слово await можно использовать только в функциях, объявленных с ключевым словом async. Оно позволяет организовать ожидание разрешения промиса. Если мы используем промисы за пределами async-функций, нам всё ещё нужно использовать коллбэки блока then:
      - рис. [Ключевое слово await можно использовать только в функциях, объявленных с ключевым словом async]
    - 5 советов по написанию надёжного асинхронного кода, который легко поддерживать
      - Прямо из статьи уже сделать слайды. Т.к. уже и так много. https://habr.com/ru/company/ruvds/blog/340508/
      - Чистота кода. Использование конструкции async / await позволяет вам писать гораздо меньше кода.
      - Обработка ошибок. Конструкция async / await позволяет обрабатывать синхронные и асинхронные ошибки с использованием одних и тех же механизмов. А именно, речь идёт о широко известном выражении try / catch.
      - Обработка условий. Применение async / await упрощает написание кода, использующего условия. Вот — код, основанный на промисах:
      - Трассировка стека. В отличие от async / await, стек ошибки, возвращённый из цепочки промисов, не содержит сведений о точном месте, в котором произошла ошибка.
  - DOM
- Современный JS (ES6+)

  - Что основного добавил ES6
    - сlasses and modules
    - iterators and for/of loops
    - Python-style generators
    - arrow functions
    - binary data
    - typed arrays
    - collections (maps, sets and weak maps)
    - promises
    - number and math enhancements
    - reflection
    - and proxies (metaprogramming for virtual objects and wrappers)
    - and many others
  - ES7 (ECMAScript 2016)
    - exponentiation operator (`**`)
    - Array.prototype.includes
  - ES8 (ECMAScript 2017)
    - async/await, which works using generators and promises
  - ES9 (ECMAScript 2018)
    - rest/spread properties
    - asynchronous iteration
    - Promise.prototype.finally()
    - additions to RegExp
  - ES.Next - features are more correctly called proposals, because, by definition, the specification has not been finalized yet
    -

- LocalStorage
- WebWorkers
- ServiceWorkers

- На будущее
  - Может получиться очень хороший рассказ о том как работает JS(движок и вещи рядом) на основе картинки взаимодействия движка с WebApi(document, XHR, setTimeout) и с EventLoop + CallbackQueue(onClick, onLoad, onDone), опираясь на цикл статей.
- Источники
  - http://jem-space.ru/kak-rabotaiet-javascript/
  - https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e
  - Цикл статей.
    - Как работает JS: цикл событий, асинхронность и пять способов улучшения кода с помощью async / await https://habr.com/ru/company/ruvds/blog/340508/
    - Как работает JS: обзор движка, механизмов времени выполнения, стека вызовов https://habr.com/ru/company/ruvds/blog/337042/
- Ссылки
  - https://babeljs.io/docs/en/learn.html
